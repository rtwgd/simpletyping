<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>日本語タイピング練習</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #323437;
            color: #d1d0c5;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 300;
            color: #e2b714;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1rem;
            color: #646669;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #646669;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            cursor: pointer;
        }

        .custom-input {
            width: 100px;
            background: #2c2e31;
            color: #d1d0c5;
            border: 2px solid #646669;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        select, button {
            background: #2c2e31;
            color: #d1d0c5;
            border: 2px solid #646669;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        select:hover, button:hover, .custom-input:hover {
            border-color: #e2b714;
        }
        .custom-input:focus {
            outline: none;
            border-color: #e2b714;
        }

        .test-area {
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            cursor: text;
        }

        .word-display {
    background: #2c2e31;
    padding: 30px;
    border-radius: 8px;
    font-size: 1.8rem;
    line-height: 2.2;
    height: auto;
    max-height: calc( (1.8rem * 2.2) * 5 + 60px ); /* 最大5行分 + padding でクランプ */
    border: 2px solid transparent;
    transition: border-color 0.2s, height 0.2s ease;
    overflow: hidden;
    position: relative;
}


        /* 変更: wordStream を絶対配置から相対配置へし、折り返しを有効にする */
#wordStream {
    position: relative; /* absolute -> relative に変更 */
    width: 100%;
    transition: transform 0.3s ease-in-out;
    white-space: normal; /* 折り返し有効化 */
    word-break: break-word;
    display: block; /* 各 .word は inline-block のまま折り返される */
}

/* word-display の高さは JS で動的に決めるため min/max を指定しておく */
.word-display {
    background: #2c2e31;
    padding: 30px;
    border-radius: 8px;
    font-size: 1.8rem;
    line-height: 2.2;
    /* 固定高さの calc() を削除して自動に。JS で height を上書きします */
    height: auto;
    max-height: 80vh; /* 極端に大きくならないように上限を設定 */
    border: 2px solid transparent;
    transition: border-color 0.2s, height 0.2s ease;
    overflow: hidden;
    position: relative;
}

/* 各ワード要素が枠の右にはみ出すことを防ぐ */
.word {
    display: inline-block;
    margin-right: 1rem;
    margin-bottom: 0.5rem;
    transition: color 0.2s;
    max-width: 100%;
    box-sizing: border-box;
}


        .word.current {
            color: #e2b714;
        }

        .kana-display {
            font-size: 1.4rem;
            color: #646669;
            margin-top: 15px;
            height: 2.5em;
            text-align: center;
            letter-spacing: 2px;
            background: #2c2e31;
            padding: 10px;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .kana-stream {
            position: absolute;
            top: 10px; /* Same as padding */
            left: 50%;
            white-space: nowrap;
        }

        .kana-stream .typed {
            color: #d1d0c5;
        }
        .kana-stream .untyped {
            opacity: 0.5;
        }

        #cursor {
            display: inline-block;
            background-color: #e2b714;
            width: 2px;
            height: 1.4rem;
            vertical-align: middle;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
        }

        .stat {
            text-align: center;
            min-width: 80px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #e2b714;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #646669;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .results {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .results.show {
            display: flex;
        }

        .results-content {
            background: #2c2e31;
            padding: 40px;
            border-radius: 8px;
            text-align: center;
            width: 90%;
            max-width: 600px;
        }

        .results h2 {
            color: #e2b714;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .restart-btn {
            background: #e2b714;
            color: #323437;
            font-weight: bold;
            padding: 12px 24px;
            font-size: 1.1rem;
        }

        .restart-btn:hover {
            background: #f4c430;
            border-color: #f4c430;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #646669;
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #e2b714;
            width: 0%;
            transition: width 0.3s ease;
        }
        /* モーダル全体の背景 */
.modal {
  position: fixed;
  inset: 0;
  display: none;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.6);
  z-index: 200;
}

/* モーダル表示時 */
.modal.show {
  display: flex;
}

/* モーダル内コンテンツ */
.modal-content {
  background: #2c2e31;
  color: #d1d0c5;
  padding: 20px;
  border-radius: 8px;
  width: 90%;
  max-width: 640px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

/* 閉じるボタン */
.modal-close {
  background: #e2b714;
  color: #323437;
  border: none;
  padding: 6px 10px;
  border-radius: 4px;
  float: right;
  cursor: pointer;
}

/* レベル表のラッパー（横スクロール対応） */
.level-table-wrapper {
  overflow-x: auto;
  margin-top: 12px;
}

/* テーブル */
#levelTable {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.95rem;
}
#levelTable thead th {
  text-align: left;
  padding: 8px 10px;
  color: #323437;
  background: #e2b714;
}
#levelTable tbody td {
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}
#levelTable tbody tr:nth-child(odd) {
  background: rgba(255,255,255,0.02);
}

    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">日本語タイピング練習</h1>
        <p class="subtitle">Japanese Typing Practice</p>
    </div>
    
<div id="levelModal" class="modal">
  <div class="modal-content">
    <button id="closeLevelBtn" class="modal-close">閉じる</button>
    <h2>レベル判定一覧</h2>
    <div class="level-table-wrapper">
      <table id="levelTable">
        <thead><tr><th>Level</th><th>KPM しきい値</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>
    <div class="controls">
        <button id="showLevelBtn">レベル一覧</button>
        <div class="control-group">
            <label for="wordCountSelect">単語数:</label>
            <select id="wordCountSelect">
                <option value="15">15</option>
                <option value="30" selected>30</option>
                <option value="50">50</option>
                <option value="100">100</option>
            </select>
            <input type="number" id="customWordCount" class="custom-input" placeholder="カスタム" min="1">
        </div>
        
        <div class="control-group">
            <label for="timeLimitSelect">時間(秒):</label>
            <select id="timeLimitSelect">
                <option value="30">30</option>
                <option value="60" selected>60</option>
                <option value="120">120</option>
                <option value="0">無制限</option>
            </select>
            <input type="number" id="customTimeLimit" class="custom-input" placeholder="カスタム" min="0">
        </div>

        <div class="control-group">
            <input type="checkbox" id="spaceToggle" checked>
            <label for="spaceToggle">スペース入力を必須にする</label>
        </div>
        
        <button id="restartBtn">再スタート</button>
    </div>

    <div class="test-area" id="testArea">
        <div id="wordDisplay" class="word-display">
            <div id="wordStream"></div>
        </div>
        <div id="kanaDisplay" class="kana-display">
            <div id="kanaStream" class="kana-stream"></div>
        </div>
        <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>
    </div>

    <div class="stats">
        <div class="stat">
            <span id="kpm" class="stat-value">0</span>
            <span class="stat-label">KPM</span>
        </div>
        <div class="stat">
            <span id="kps" class="stat-value">0.00</span>
            <span class="stat-label">KPS</span>
        </div>
        <div class="stat">
            <span id="accuracy" class="stat-value">100%</span>
            <span class="stat-label">正確性</span>
        </div>
        <div class="stat">
            <span id="timer" class="stat-value">60</span>
            <span class="stat-label">時間</span>
        </div>
    </div>

    <div id="results" class="results">
        <div class="results-content">
            <h2>結果</h2>
            <div class="results-grid">
                <div class="stat">
                    <span id="finalLevel" class="stat-value">-</span>
                    <span class="stat-label">Level</span>
                </div>
                <div class="stat">
                    <span id="finalKPM" class="stat-value">0</span>
                    <span class="stat-label">KPM</span>
                </div>
                <div class="stat">
                    <span id="finalKPS" class="stat-value">0.00</span>
                    <span class="stat-label">KPS</span>
                </div>
                <div class="stat">
                    <span id="finalAccuracy" class="stat-value">100%</span>
                    <span class="stat-label">正確性</span>
                </div>
                <div class="stat">
                    <span id="finalTime" class="stat-value">0</span>
                    <span class="stat-label">経過時間</span>
                </div>
            </div>
            <button id="restartBtnResults" class="restart-btn">もう一度</button>
        </div>
    </div>

    <script>
    (async () => {
        // --- Logic from typing.ts (transpiled to JS) ---
        class ChunkPattern {
        }
        ChunkPattern.list = new Map([
            ["あ", [["a"]]], ["い", [["i"], ["yi"]]], ["う", [["u"], ["wu"], ["whu"]]], ["え", [["e"]]], ["お", [["o"]]],
            ["うぁ", [["wha"]]], ["うぃ", [["wi"], ["whi"]]], ["うぇ", [["we"], ["whe"]]], ["うぉ", [["who"]]],
            ["ゐ", [["wi"]]], ["ゑ", [["we"]]], ["ぁ", [["la"], ["xa"]]], ["ぃ", [["li"], ["xi"], ["lyi"], ["xyi"]]], ["ぅ", [["lu"], ["xu"]]], ["ぇ", [["le"], ["xe"], ["lye"], ["xye"]]], ["ぉ", [["lo"], ["xo"]]],
            ["ぃぇ", [["ye"]]], ["か", [["ka"], ["ca"]]], ["き", [["ki"]]], ["く", [["ku"], ["cu"], ["qu"]]], ["け", [["ke"]]], ["こ", [["ko"], ["co"]]],
            ["きゃ", [["kya"]]], ["きぃ", [["kyi"]]], ["きゅ", [["kyu"]]], ["きぇ", [["kye"]]], ["きょ", [["kyo"]]],
            ["くゃ", [["qya"]]], ["くゅ", [["qyu"]]], ["くょ", [["qyo"]]], ["くぁ", [["qa"], ["qwa"], ["kwa"]]], ["くぃ", [["qi"], ["qwi"], ["qyi"]]], ["くぅ", [["qwu"]]], ["くぇ", [["qe"], ["qwe"], ["qye"]]], ["くぉ", [["qo"], ["qwo"]]],
            ["が", [["ga"]]], ["ぎ", [["gi"]]], ["ぐ", [["gu"]]], ["げ", [["ge"]]], ["ご", [["go"]]],
            ["ぎゃ", [["gya"]]], ["ぎぃ", [["gyi"]]], ["ぎゅ", [["gyu"]]], ["ぎぇ", [["gye"]]], ["ぎょ", [["gyo"]]],
            ["ぐぁ", [["gwa"]]], ["ぐぃ", [["gwi"]]], ["ぐぅ", [["gwu"]]], ["ぐぇ", [["gwe"]]], ["ぐぉ", [["gwo"]]],
            ["ヵ", [["lka"], ["xka"]]], ["ヶ", [["lke"], ["xke"]]], ["さ", [["sa"]]], ["し", [["si"], ["ci"], ["shi"]]], ["す", [["su"]]], ["せ", [["se"], ["ce"]]], ["そ", [["so"]]],
            ["しゃ", [["sya"], ["sha"]]], ["しぃ", [["syi"]]], ["しゅ", [["syu"], ["shu"]]], ["しぇ", [["sye"], ["she"]]], ["しょ", [["syo"], ["sho"]]],
            ["すぁ", [["swa"]]], ["すぃ", [["swi"]]], ["すぅ", [["swu"]]], ["すぇ", [["swe"]]], ["すぉ", [["swo"]]],
            ["ざ", [["za"]]], ["じ", [["zi"], ["ji"]]], ["ず", [["zu"]]], ["ぜ", [["ze"]]], ["ぞ", [["zo"]]],
            ["じゃ", [["ja"], ["zya"], ["jya"]]], ["じぃ", [["zyi"], ["jyi"]]], ["じゅ", [["ju"], ["zyu"], ["jyu"]]], ["じぇ", [["je"], ["zye"], ["jye"]]], ["じょ", [["jo"], ["zyo"], ["jyo"]]],
            ["た", [["ta"]]], ["ち", [["ti"], ["chi"]]], ["つ", [["tu"], ["tsu"]]], ["て", [["te"]]], ["と", [["to"]]],
            ["ちゃ", [["tya"], ["cha"], ["cya"]]], ["ちぃ", [["tyi"], ["cyi"]]], ["ちゅ", [["tyu"], ["chu"], ["cyu"]]], ["ちぇ", [["tye"], ["che"], ["cye"]]], ["ちょ", [["tyo"], ["cho"], ["cyo"]]],
            ["つぁ", [["tsa"]]], ["つぃ", [["tsi"]]], ["つぇ", [["tse"]]], ["つぉ", [["tso"]]],
            ["てゃ", [["tha"]]], ["てぃ", [["thi"]]], ["てゅ", [["thu"]]], ["てぇ", [["the"]]], ["てょ", [["tho"]]],
            ["とぁ", [["twa"]]], ["とぃ", [["twi"]]], ["とぅ", [["twu"]]], ["とぇ", [["twe"]]], ["とぉ", [["two"]]],
            ["だ", [["da"]]], ["ぢ", [["di"]]], ["づ", [["du"]]], ["で", [["de"]]], ["ど", [["do"]]],
            ["ぢゃ", [["dya"]]], ["ぢぃ", [["dyi"]]], ["ぢゅ", [["dyu"]]], ["ぢぇ", [["dye"]]], ["ぢょ", [["dyo"]]],
            ["でゃ", [["dha"]]], ["でぃ", [["dhi"]]], ["でゅ", [["dhu"]]], ["でぇ", [["dhe"]]], ["でょ", [["dho"]]],
            ["どぁ", [["dwa"]]], ["どぃ", [["dwi"]]], ["どぅ", [["dwu"]]], ["どぇ", [["dwe"]]], ["どぉ", [["dwo"]]],
            ["っ", [["ltu"], ["xtu"], ["ltsu"], ["xtsu"]]], ["な", [["na"]]], ["に", [["ni"]]], ["ぬ", [["nu"]]], ["ね", [["ne"]]], ["の", [["no"]]],
            ["にゃ", [["nya"]]], ["にぃ", [["nyi"]]], ["にゅ", [["nyu"]]], ["にぇ", [["nye"]]], ["にょ", [["nyo"]]],
            ["は", [["ha"]]], ["ひ", [["hi"]]], ["ふ", [["hu"], ["fu"]]], ["へ", [["he"]]], ["ほ", [["ho"]]],
            ["ひゃ", [["hya"]]], ["ひぃ", [["hyi"]]], ["ひゅ", [["hyu"]]], ["ひぇ", [["hye"]]], ["ひょ", [["hyo"]]],
            ["ふぁ", [["fa"], ["fwa"]]], ["ふぃ", [["fi"], ["fwi"], ["fyi"]]], ["ふぅ", [["fwu"]]], ["ふぇ", [["fe"], ["fwe"], ["fye"]]], ["ふぉ", [["fo"], ["fwo"]]],
            ["ふゃ", [["fya"]]], ["ふゅ", [["fyu"]]], ["ふょ", [["fyo"]]], ["ば", [["ba"]]], ["び", [["bi"]]], ["ぶ", [["bu"]]], ["べ", [["be"]]], ["ぼ", [["bo"]]],
            ["びゃ", [["bya"]]], ["びぃ", [["byi"]]], ["びゅ", [["byu"]]], ["びぇ", [["bye"]]], ["びょ", [["byo"]]],
            ["ヴぁ", [["va"]]], ["ヴぃ", [["vi"]]], ["ヴ", [["vu"]]], ["ヴぇ", [["ve"]]], ["ヴぉ", [["vo"]]],
            ["ヴゃ", [["vya"]]], ["ヴぃ", [["vyi"]]], ["ヴゅ", [["vyu"]]], ["ヴぇ", [["vye"]]], ["ヴょ", [["vyo"]]],
            ["ぱ", [["pa"]]], ["ぴ", [["pi"]]], ["ぷ", [["pu"]]], ["ぺ", [["pe"]]], ["ぽ", [["po"]]],
            ["ぴゃ", [["pya"]]], ["ぴぃ", [["pyi"]]], ["ぴゅ", [["pyu"]]], ["ぴぇ", [["pye"]]], ["ぴょ", [["pyo"]]],
            ["ま", [["ma"]]], ["み", [["mi"]]], ["む", [["mu"]]], ["め", [["me"]]], ["も", [["mo"]]],
            ["みゃ", [["mya"]]], ["みぃ", [["myi"]]], ["みゅ", [["myu"]]], ["みぇ", [["mye"]]], ["みょ", [["myo"]]],
            ["や", [["ya"]]], ["ゆ", [["yu"]]], ["よ", [["yo"]]], ["ゃ", [["lya"], ["xya"]]], ["ゅ", [["lyu"], ["xyu"]]], ["ょ", [["lyo"], ["xyo"]]],
            ["ら", [["ra"]]], ["り", [["ri"]]], ["る", [["ru"]]], ["れ", [["re"]]], ["ろ", [["ro"]]],
            ["りゃ", [["rya"]]], ["りぃ", [["ryi"]]], ["りゅ", [["ryu"]]], ["りぇ", [["rye"]]], ["りょ", [["ryo"]]],
            ["わ", [["wa"]]], ["を", [["wo"]]], ["ん", [["n"], ["nn"], ["n'"], ["xn"]]], ["ゎ", [["lwa"], ["xwa"]]], ["ー", [["-"]]], ["　", [[" "]]]
        ]);
        ChunkPattern._initialize = (() => {
            for (const chunkPattern of ChunkPattern.list) {
                const kana = chunkPattern[0];
                if (kana.length >= 2) {
                    let multiPattern = [];
                    for (const c of kana) {
                        if (multiPattern.length === 0) {
                            multiPattern = ChunkPattern.list.get(c);
                        }
                        else {
                            const tmp = [];
                            for (const p1 of multiPattern) {
                                for (const p2 of ChunkPattern.list.get(c)) {
                                    tmp.push(p1.concat(p2));
                                }
                            }
                            multiPattern = tmp;
                        }
                    }
                    ChunkPattern.list.set(kana, chunkPattern[1].concat(multiPattern));
                }
            }
        })();

        function devideIntoChunk(kana) {
            const ret = [];
            for (let i = 0; i < kana.length; ++i) {
                if (i >= kana.length - 1) {
                    ret.push(new Chunk(kana[i]));
                    break;
                }
                if (kana[i] !== "っ" && kana[i] !== "ん") {
                    if (!ChunkPattern.list.has(kana[i] + kana[i + 1])) {
                        ret.push(new Chunk(kana[i]));
                    }
                    else {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        ++i;
                    }
                }
                else {
                    if (i >= kana.length - 2) {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        break;
                    }
                    if (!ChunkPattern.list.has(kana[i + 1] + kana[i + 2])) {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        ++i;
                    }
                    else {
                        ret.push(new Chunk(kana[i] + kana[i + 1] + kana[i + 2]));
                        i += 2;
                    }
                }
            }
            return ret;
        }

        class TypePattern {
            constructor(romanList) {
                this._isValid = true;
                this._romanCount = 0;
                this._curKanaRomanIndex = 0;
                this._curKanaRomanCount = 0;
                this._kanaRomanList = romanList;
                this._roman = romanList.join("");
            }
                        getCurChar() {
                // 安全に現在のローマ1文字を返す。無ければ空文字。
                return this._roman[this._romanCount] || '';
            }

            increment(kanaFinished) {
                ++this._romanCount;
                ++this._curKanaRomanCount;
                if (this._curKanaRomanCount >= this._curKanaRoman.length) {
                    ++this._curKanaRomanIndex;
                    this._curKanaRomanCount = 0;
                    kanaFinished(this._curKanaRomanIndex);
                }
            }
            get _curKanaRoman() {
                return this._kanaRomanList[this._curKanaRomanIndex];
            }
            get isValid() {
                return this._isValid;
            }
            isChunkFinished() {
                return this._romanCount >= this._roman.length;
            }
            invalidate() {
                this._isValid = false;
            }
        }

        class TypePatternList {
            constructor(romanLists) {
                this._displayPatternNum = 0;
                this._isChunkFinished = false;
                this._additionalRomanCount = 0;
                this._typePatternList = romanLists.map((romanList) => new TypePattern(romanList));
            }
            isCorrectInput(inputChar) {
                for (const typePattern of this._typePatternList) {
                    if (typePattern.isValid && typePattern.getCurChar() === inputChar)
                        return true;
                }
                return false;
            }
            update(inputChar, kanaFinished) {
                if (!this.isCorrectInput(inputChar)) {
                    return false;
                }
                for (const typePattern of this._typePatternList) {
                    if (!typePattern.isValid)
                        continue;
                    if (inputChar === typePattern.getCurChar()) {
                        typePattern.increment(kanaFinished);
                        if (typePattern.isChunkFinished()) {
                            this._isChunkFinished = true;
                            continue;
                        }
                    }
                    else {
                        if (typePattern === this._typePatternList[this._displayPatternNum]) {
                            this._displayPatternNum = -1;
                        }
                        typePattern.invalidate();
                    }
                }
                if (this._displayPatternNum === -1) {
                    for (let i = 0; i < this._typePatternList.length; ++i) {
                        if (this._typePatternList[i].isValid) {
                            this._displayPatternNum = i;
                            break;
                        }
                    }
                }
                return true;
            }
            get isChunkFinished() {
                return this._isChunkFinished;
            }
        }

        class Chunk {
            constructor(kana) {
                this._kanaCount = 0;
                this._xtuVowels = ["a", "i", "u", "e", "o", "n"];
                this._xnVowels = this._xtuVowels.concat(["y"]);
                this._kana = kana;
                if (!ChunkPattern.list.has(kana)) {
                    // This case handles combined chunks like 'ん　'
                    if (kana.length > 1 && ChunkPattern.list.has(kana[0]) && ChunkPattern.list.has(kana.substr(1))) {
                         const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        const xnPatterns = ChunkPattern.list.get(kana[0]); // Assuming the first char is special (like 'ん')
                        for (const roman of curPatterns) {
                            for (const xn of xnPatterns) {
                                if (xn[0] !== "n") {
                                    newPatterns.push(xn.concat(roman));
                                }
                                else {
                                    if (!this._xnVowels.includes(roman[0][0])) {
                                        newPatterns.push(xn.concat(roman));
                                    }
                                }
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    } else {
                        this._typePatternList = new TypePatternList([[]]); // Empty/invalid
                    }
                } else if (kana.length == 1) {
                    this._typePatternList = new TypePatternList(ChunkPattern.list.get(kana));
                }
                else {
                    if (kana[0] === "っ") {
                        const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        for (const roman of curPatterns) {
                            const romanFirstChar = roman[0][0];
                            if (!this._xtuVowels.includes(romanFirstChar)) {
                                newPatterns.push([romanFirstChar].concat(roman));
                            }
                        }
                        for (const roman of curPatterns) {
                            for (const xtu of ChunkPattern.list.get("っ")) {
                                newPatterns.push(xtu.concat(roman));
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    }
                    else if (kana[0] === "ん") {
                        const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        const xnPatterns = ChunkPattern.list.get("ん");
                        for (const roman of curPatterns) {
                            for (const xn of xnPatterns) {
                                if (xn[0] !== "n") {
                                    newPatterns.push(xn.concat(roman));
                                }
                                else {
                                    if (!this._xnVowels.includes(roman[0][0])) {
                                        newPatterns.push(xn.concat(roman));
                                    }
                                }
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    }
                    else {
                        this._typePatternList = new TypePatternList(ChunkPattern.list.get(kana));
                    }
                }
            }
            update(inputChar) {
                const kanaFinished = (newKanaCount) => {
                    this._kanaCount = newKanaCount;
                };
                const ret = this._typePatternList.update(inputChar, kanaFinished);
                if (this._typePatternList.isChunkFinished) {
                    this._kanaCount = this._kana.length;
                }
                return ret;
            }
            get kanaCount() {
                return this._kanaCount;
            }
            get isChunkFinished() {
                return this._typePatternList.isChunkFinished;
            }
            get kana() {
                return this._kana;
            }
        }

        class WordTyper {
            constructor(kana) {
                this.kana = kana;
                this.chunks = devideIntoChunk(kana);
                this.chunkIndex = 0;
            }

                                    update(key) {
                if (this.isFinished()) return { isCorrect: false };

                const currentChunk = this.chunks[this.chunkIndex];
                // 普通の更新をまず試す
                let isCorrect = currentChunk.update(key);

                // もし通常更新で不正と判定され、かつ現在チャンクが促音（っ）を先頭に持つとき、
                // 次チャンクの期待する先頭文字が今回の入力キーと一致すれば促音処理を強制する
                if (!isCorrect) {
                    const nextChunk = this.chunks[this.chunkIndex + 1];
                    if (currentChunk && typeof currentChunk.kana === 'string' && currentChunk.kana[0] === 'っ' && nextChunk) {
                        try {
                            const tplContainer = nextChunk._typePatternList;
                            const tpl = tplContainer && tplContainer._typePatternList;
                            if (tpl && tpl.length > 0) {
                                // nextChunk のいずれかの TypePattern が現在期待している文字（getCurChar）が key と一致するかを調べる
                                let matchNextFirstChar = false;
                                for (const tp of tpl) {
                                    const c = (tp.getCurChar && tp.getCurChar()) || '';
                                    if (c === key) {
                                        matchNextFirstChar = true;
                                        break;
                                    }
                                }
                                if (matchNextFirstChar) {
                                    // --- ここで促音チャンクを強制的に完了扱いにする ---
                                    // currentChunk._kanaCount を直接操作して促音を完了させる
                                    // （Chunk クラスのゲッターは kanaCount を参照しているため、これで完了扱いになる）
                                    try {
                                        currentChunk._kanaCount = currentChunk._kana.length;
                                    } catch (e) {
                                        // 何か失敗しても先に進めないだけなので無視
                                    }
                                    // chunkIndex を進めて次チャンクに移る
                                    this.chunkIndex++;

                                    // 同じ key を次チャンクへ再帰的に適用して消費させる
                                    if (!this.isFinished()) {
                                        return this.update(key);
                                    } else {
                                        // 次チャンクが存在しない場合は成功扱いにする
                                        return { isCorrect: true, isFinished: this.isFinished() };
                                    }
                                }
                            }
                        } catch (err) {
                            // 内部アクセスに失敗した場合は通常の不正扱いに落とす
                        }
                    }
                }

                // currentChunk が完了していれば index を進める（通常経路）
                if (currentChunk.isChunkFinished) {
                    this.chunkIndex++;
                }

                return {
                    isCorrect,
                    isFinished: this.isFinished(),
                };
            }



            isFinished() {
                return this.chunkIndex >= this.chunks.length;
            }
            
            getTypedKana() {
                if (this.isFinished()) return this.kana;
                const completedKana = this.chunks.slice(0, this.chunkIndex).map(c => c.kana).join('');
                const partialChunk = this.chunks[this.chunkIndex];
                const partialKana = partialChunk ? partialChunk.kana.substring(0, partialChunk.kanaCount) : '';
                return completedKana + partialKana;
            }
        }

        const levelMap = [
            { level: 'ZZ', kpm: 4000 }, { level: 'ZX', kpm: 3000 }, { level: 'ZS', kpm: 2400 },
            { level: 'ZA', kpm: 2000 }, { level: 'ZB', kpm: 1714.29 }, { level: 'ZC', kpm: 1500 },
            { level: 'ZD', kpm: 1333.33 }, { level: 'ZE', kpm: 1200 }, { level: 'ZF', kpm: 1090.91 },
            { level: 'ZG', kpm: 1000 }, { level: 'ZH', kpm: 923.08 }, { level: 'ZI', kpm: 857.14 },
            { level: 'ZJ', kpm: 800 }, { level: 'XX', kpm: 750 }, { level: 'XS', kpm: 705.88 },
            { level: 'XA', kpm: 666.67 }, { level: 'XB', kpm: 631.58 }, { level: 'XC', kpm: 600 },
            { level: 'XD', kpm: 571.43 }, { level: 'XE', kpm: 545.45 }, { level: 'XF', kpm: 521.74 },
            { level: 'XG', kpm: 500 }, { level: 'XH', kpm: 480 }, { level: 'XI', kpm: 461.54 },
            { level: 'XJ', kpm: 444.44 }, { level: 'SS', kpm: 428.57 }, { level: 'SA', kpm: 413.79 },
            { level: 'SB', kpm: 400 }, { level: 'SC', kpm: 387.10 }, { level: 'SD', kpm: 375 },
            { level: 'SE', kpm: 363.64 }, { level: 'SF', kpm: 352.94 }, { level: 'SG', kpm: 342.86 },
            { level: 'SH', kpm: 333.33 }, { level: 'SI', kpm: 324.32 }, { level: 'SJ', kpm: 315.79 },
            { level: 'A', kpm: 300 }, { level: 'B', kpm: 279.07 }, { level: 'C', kpm: 255.32 },
            { level: 'D', kpm: 230.77 }, { level: 'E', kpm: 206.90 }, { level: 'F', kpm: 184.62 },
            { level: 'G', kpm: 164.38 }, { level: 'H', kpm: 146.34 }, { level: 'I', kpm: 130.43 },
            { level: 'J', kpm: 116.50 }
        ];

        function getLevel(kpm) {
            for (const item of levelMap) {
                if (kpm >= item.kpm) {
                    return item.level;
                }
            }
            return '-';
        }

        class TypingTest {
            constructor(wordsData) {
                this.allWords = wordsData;
                this.initGame();
                this.initElements();
                this.initEventListeners();
                this.restart();
            }
 // ----- レベル表を表示するユーティリティ -----
function createLevelTable(levelArray) {
    const tbody = document.querySelector('#levelTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';
    for (const item of levelArray) {
        const tr = document.createElement('tr');
        const tdLevel = document.createElement('td');
        tdLevel.textContent = item.level;
        const tdKpm = document.createElement('td');
        tdKpm.textContent = Math.round(item.kpm);
        tr.appendChild(tdLevel);
        tr.appendChild(tdKpm);
        tbody.appendChild(tr);
    }
}

// モーダルの開閉ハンドラ登録（DOMContentLoaded 後に呼ぶ）
document.addEventListener('DOMContentLoaded', () => {
    // テーブル作成
    createLevelTable(levelMap);

    const showBtn = document.getElementById('showLevelBtn');
    const modal = document.getElementById('levelModal');
    const closeBtn = document.getElementById('closeLevelBtn');

    if (showBtn && modal) {
        showBtn.addEventListener('click', () => {
            modal.classList.add('show');
        });
    }
    if (closeBtn && modal) {
        closeBtn.addEventListener('click', () => {
            modal.classList.remove('show');
        });
    }
    // モーダル外クリックで閉じる
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('show');
        });
    }
});

            initGame() {
                this.words = [];
                this.wordBoundaries = [];
                this.fullKanaString = '';
                this.wordTyper = null;
                this.correctTypedKeys = 0;
                this.incorrectChars = 0;
                this.totalTypedChars = 0;
                this.startTime = null;
                this.endTime = null;
                this.timer = null;
                this.timeLeft = 60;
                this.isActive = false;
                this.isCompleted = false;
                this.lastScrolledLine = -1;
            }

            initElements() {
                this.testArea = document.getElementById('testArea');
                this.wordDisplay = document.getElementById('wordDisplay');
                this.wordStream = document.getElementById('wordStream');
                this.kanaDisplay = document.getElementById('kanaDisplay');
                this.kanaStream = document.getElementById('kanaStream');
                this.kpmElement = document.getElementById('kpm');
                this.kpsElement = document.getElementById('kps');
                this.accuracyElement = document.getElementById('accuracy');
                this.timerElement = document.getElementById('timer');
                this.results = document.getElementById('results');
                this.wordCountSelect = document.getElementById('wordCountSelect');
                this.customWordCount = document.getElementById('customWordCount');
                this.timeLimitSelect = document.getElementById('timeLimitSelect');
                this.customTimeLimit = document.getElementById('customTimeLimit');
                this.spaceToggle = document.getElementById('spaceToggle');
                this.restartBtn = document.getElementById('restartBtn');
                this.restartBtnResults = document.getElementById('restartBtnResults');
                this.progressFill = document.getElementById('progressFill');
            }

            initEventListeners() {
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                this.testArea.addEventListener('click', () => this.startTest());
                this.restartBtn.addEventListener('click', () => this.restart());
                this.restartBtnResults.addEventListener('click', () => this.restart());
                this.wordCountSelect.addEventListener('change', () => this.restart());
                this.customWordCount.addEventListener('change', () => this.restart());
                this.timeLimitSelect.addEventListener('change', () => this.restart());
                this.customTimeLimit.addEventListener('change', () => this.restart());
                this.spaceToggle.addEventListener('change', () => this.restart());
                // ウィンドウサイズが変わったら行数再計算と高さ調整を行う
window.addEventListener('resize', () => {
    // レイアウトが変わるため行割りを再計算して高さを再設定
    this.calculateLines();
    this.adjustWordDisplayHeight();
});

            }

            getWordCount() {
                const customCount = parseInt(this.customWordCount.value);
                if (!isNaN(customCount) && customCount > 0) {
                    return customCount;
                }
                return parseInt(this.wordCountSelect.value);
            }

            getTimeLimit() {
                const customTime = parseInt(this.customTimeLimit.value);
                if (!isNaN(customTime) && customTime >= 0) {
                    return customTime;
                }
                return parseInt(this.timeLimitSelect.value);
            }

            handleKeyDown(e) {
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'SELECT') {
                    return;
                }

                if (e.key === 'Escape') {
                    this.restart();
                    return;
                }
                if (this.isCompleted) return;
                if (e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta') return;
                if (e.ctrlKey || e.metaKey) return;

                e.preventDefault();

                if (!this.isActive) {
                    this.startTest();
                }
                
                if (e.key === 'Backspace') {
                    return; // Backspace not supported in this version
                }

                if (e.key.length > 1 && e.key !== ' ') return;

                this.totalTypedChars++;
                const key = e.key.toLowerCase();

                const result = this.wordTyper.update(key);

                if (result.isCorrect) {
                    this.correctTypedKeys++;
                } else {
                    this.incorrectChars++;
                }

                const typedKana = this.wordTyper.getTypedKana();
                const boundary = this.wordBoundaries.find(b => typedKana.length === b.endIndex);

                if (boundary) {
                    if (!this.spaceToggle.checked) {
                        if (this.fullKanaString[typedKana.length] === '　') {
                            this.wordTyper.update(' ');
                            this.correctTypedKeys++;
                        }
                    }
                }

                this.updateScrolling();
                this.updateWordHighlight();

                if (this.wordTyper.isFinished()) {
                    this.completeTest();
                    return;
                }
                this.updateStats();
            }

            // --- generateWords の置換版 ---
generateWords() {
    const wordCount = this.getWordCount();
    this.words = this.allWords.sort(() => 0.5 - Math.random()).slice(0, wordCount);

    this.wordBoundaries = [];
    let currentKanaLength = 0;

    const kanaParts = this.words.map(w => w.kana.join(''));
    this.fullKanaString = kanaParts.join('　');

    // クリア
    this.wordStream.innerHTML = '';

    // 一旦すべての単語を追加してから行レイアウト（折り返し）を評価する
    this.words.forEach((word, index) => {
        const wordEl = document.createElement('span');
        wordEl.id = `word-span-${index}`;
        wordEl.className = 'word';
        wordEl.textContent = word.text;
        this.wordStream.appendChild(wordEl);
        // DOM 上で単語と単語の間にスペースを入れる（見た目用）
        const space = document.createTextNode(' ');
        this.wordStream.appendChild(space);

        const kanaLength = kanaParts[index].length;
        this.wordBoundaries.push({
            startIndex: currentKanaLength,
            endIndex: currentKanaLength + kanaLength,
            element: wordEl
        });
        currentKanaLength += kanaLength + 1; // +1 for the space in fullKanaString
    });

    // WordTyper を作る前にレイアウト情報を確定する
    this.calculateLines();

    this.wordTyper = new WordTyper(this.fullKanaString);

    // 表示枠の高さを単語行数に応じて調整する
    this.adjustWordDisplayHeight();

    this.updateScrolling();
    this.updateWordHighlight();
}

// --- calculateLines の置換版 ---
calculateLines() {
    // lineBreakWordIndices を行の開始単語インデックスで作る
    this.lineBreakWordIndices = [0];
    const wordSpans = Array.from(this.wordStream.querySelectorAll('.word'));
    if (wordSpans.length === 0) return;

    let lastOffsetTop = wordSpans[0].offsetTop;
    for (let i = 1; i < wordSpans.length; i++) {
        const t = wordSpans[i].offsetTop;
        // offsetTop が変化したら改行が発生したとみなす
        if (t > lastOffsetTop + 1) { // 微小差を吸収
            this.lineBreakWordIndices.push(i);
            lastOffsetTop = t;
        }
    }
    // 最後の行も意識しておく（行数を容易に算出するため）
    // lineBreakWordIndices 配列は各行の先頭 word index を保持する
}

// --- 新規追加メソッド: 表示枠高さ調整 ---
// 既存の adjustWordDisplayHeight() をこの実装に置き換えてください
adjustWordDisplayHeight() {
    const MAX_LINES = 5;

    if (!this.lineBreakWordIndices || this.lineBreakWordIndices.length === 0) {
        this.wordDisplay.style.height = '';
        return;
    }

    // 行数を取得（lineBreakWordIndices は各行の先頭単語インデックス）
    const lineCount = this.lineBreakWordIndices.length;

    // 実際に使用する行数は lineCount と MAX_LINES の小さい方
    const usedLines = Math.min(lineCount, MAX_LINES);

    // 行高(px)を取得する。まず wordStream 内の最初の word 要素から取得を試みる
    let lineHeightPx = 0;
    const sampleEl = this.wordStream.querySelector('.word');
    if (sampleEl) {
        const cs = getComputedStyle(sampleEl);
        lineHeightPx = parseFloat(cs.lineHeight) || 0;
    }
    if (!lineHeightPx) {
        const cs2 = getComputedStyle(this.wordDisplay);
        lineHeightPx = parseFloat(cs2.lineHeight) || parseFloat(cs2.fontSize) * 2.2 || 40;
    }

    // wordDisplay の上下 padding を考慮
    const wdCs = getComputedStyle(this.wordDisplay);
    const paddingTop = parseFloat(wdCs.paddingTop) || 0;
    const paddingBottom = parseFloat(wdCs.paddingBottom) || 0;
    const extra = 6; // 微調整用余白(px)

    // 計算：使用行数 * 行高 + padding + 余白
    const desiredHeight = Math.min(
        usedLines * lineHeightPx + paddingTop + paddingBottom + extra,
        // CSS 側の max-height でも上限がかかるためウィンドウ高さベースの安全上限も設定
        window.innerHeight * 0.8
    );

    this.wordDisplay.style.height = `${Math.round(desiredHeight)}px`;
}


            // --- 置換する関数開始 ---
updateWordHighlight() {
    const typedLength = this.wordTyper.getTypedKana().length;
    let currentWordIndex = -1;

    this.wordBoundaries.forEach((boundary, index) => {
        boundary.element.classList.remove('current');
        if (typedLength >= boundary.startIndex && typedLength < boundary.endIndex) {
            boundary.element.classList.add('current');
            currentWordIndex = index;
        }
    });

    if (currentWordIndex === -1 && typedLength >= this.fullKanaString.length) {
        this.wordBoundaries[this.wordBoundaries.length - 1].element.classList.add('current');
        currentWordIndex = this.wordBoundaries.length - 1;
    }

    if (currentWordIndex > -1) {
        // 現在の単語が属する行番号を求める
        const currentLine = this.lineBreakWordIndices.findLastIndex(lineStartIndex => currentWordIndex >= lineStartIndex);

        // 新仕様：奇数行（line index が 1,3,5...）に到達したら「一段上」にスクロールする
        // 例：currentLine === 1 のときは 0 行目を表示するために一段上にずらす
        // lastScrolledLine には最後にスクロールした「基準となる行番号」を保持して重複スクロールを防ぐ
        if (currentLine >= 1 && (currentLine % 2) === 1) {
            // スクロール先の行インデックス（表示のトップに持ってくる行の start index）
            const scrollToLineIndex = currentLine - 1;

            // 同じスクロール先に既に移動済みであれば何もしない
            if (this.lastScrolledLine !== scrollToLineIndex) {
                const firstWordIndexOfTargetLine = this.lineBreakWordIndices[scrollToLineIndex];
                const firstWordEl = this.wordBoundaries[firstWordIndexOfTargetLine].element;
                const scrollAmount = firstWordEl.offsetTop - this.wordBoundaries[0].element.offsetTop;
                this.wordStream.style.transform = `translateY(-${scrollAmount}px)`;
                this.lastScrolledLine = scrollToLineIndex;
            }
        } else {
            // currentLine が偶数か 0 のときはトップに戻す（必要なら）
            // ただし既にスクロールしていなければ何もしない
            if (currentLine === 0 && this.lastScrolledLine !== 0) {
                this.wordStream.style.transform = `translateY(0px)`;
                this.lastScrolledLine = 0;
            }
            // その他（偶数行でかつ lastScrolledLine が別の値の場合はスクロールを維持したいので何もしない）
        }
    }
}
// --- 置換する関数終了 ---


            updateScrolling() {
                if (!this.wordTyper) return;

                const typed = this.wordTyper.getTypedKana();
                const untyped = this.fullKanaString.substring(typed.length);

                this.kanaStream.innerHTML = 
                    `<span class="typed">${typed}</span>` +
                    `<span id="cursor"></span>` +
                    `<span class="untyped">${untyped}</span>`;

                const cursorEl = document.getElementById('cursor');
                if (cursorEl) {
                    const scrollOffset = cursorEl.offsetLeft;
                    this.kanaStream.style.transform = `translateX(-${scrollOffset}px)`;
                }
                this.updateProgress();
            }

            startTest() {
                if (this.isActive || this.isCompleted) return;
                
                this.isActive = true;
                this.startTime = Date.now();
                this.wordDisplay.classList.add('active');
                
                const timeLimit = this.getTimeLimit();
                if (timeLimit > 0) {
                    this.timeLeft = timeLimit;
                    this.timerElement.textContent = this.timeLeft;
                    this.startTimer();
                }
            }

            startTimer() {
                if (this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    this.timeLeft--;
                    this.timerElement.textContent = this.timeLeft;
                    this.updateStats();
                    if (this.timeLeft <= 0) {
                        this.completeTest();
                    }
                }, 1000);
            }

            completeTest() {
                this.isActive = false;
                this.isCompleted = true;
                this.endTime = Date.now();
                if (this.timer) clearInterval(this.timer);
                this.wordDisplay.classList.remove('active');
                this.showResults();
            }

            updateStats() {
                const elapsedSeconds = this.startTime ? (Date.now() - this.startTime) / 1000 : 0;
                if (elapsedSeconds === 0) return;

                const kps = this.correctTypedKeys / elapsedSeconds;
                const kpm = kps * 60;
                const accuracy = this.totalTypedChars > 0 
                    ? Math.round((this.correctTypedKeys / this.totalTypedChars) * 100)
                    : 100;

                this.kpmElement.textContent = Math.round(kpm);
                this.kpsElement.textContent = kps.toFixed(2);
                this.accuracyElement.textContent = `${Math.max(0, accuracy)}%`;
            }

            updateProgress() {
                if (!this.wordTyper) return;
                const progress = (this.wordTyper.getTypedKana().length / this.fullKanaString.length) * 100;
                this.progressFill.style.width = `${progress}%`;
            }

            showResults() {
                const elapsedSeconds = (this.endTime - this.startTime) / 1000;
                const kps = elapsedSeconds > 0 ? this.correctTypedKeys / elapsedSeconds : 0;
                const kpm = kps * 60;
                const accuracy = this.totalTypedChars > 0 
                    ? Math.round((this.correctTypedKeys / this.totalTypedChars) * 100)
                    : 100;
                const level = getLevel(kpm);

                document.getElementById('finalLevel').textContent = level;
                document.getElementById('finalKPM').textContent = Math.round(kpm);
                document.getElementById('finalKPS').textContent = kps.toFixed(2);
                document.getElementById('finalAccuracy').textContent = `${Math.max(0, accuracy)}%`;
                document.getElementById('finalTime').textContent = `${Math.round(elapsedSeconds)}s`;

                this.results.classList.add('show');
            }

            restart() {
                if (this.timer) clearInterval(this.timer);
                this.initGame();
                
                const timeLimit = this.getTimeLimit();
                this.timeLeft = timeLimit > 0 ? timeLimit : 0;

                this.wordDisplay.classList.remove('active');
                this.results.classList.remove('show');
                this.progressFill.style.width = '0%';
                this.timerElement.textContent = timeLimit > 0 ? timeLimit : '∞';
                
                this.generateWords();
                this.updateStats();
            }
        }

        async function init() {
            try {
                const response = await fetch('khjy.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                new TypingTest(data.list);
            } catch (error) {
                console.error("Could not load word list:", error);
                document.getElementById('wordDisplay').textContent = '単語リストの読み込みに失敗しました。';
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    })();
       
    </script>
</body>
</html>
