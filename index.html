<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœ¬èªã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #323437;
            color: #d1d0c5;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 300;
            color: #e2b714;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1rem;
            color: #646669;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #646669;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            cursor: pointer;
        }

        .custom-input {
            width: 100px;
            background: #2c2e31;
            color: #d1d0c5;
            border: 2px solid #646669;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        select, button {
            background: #2c2e31;
            color: #d1d0c5;
            border: 2px solid #646669;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        select:hover, button:hover, .custom-input:hover {
            border-color: #e2b714;
        }
        .custom-input:focus {
            outline: none;
            border-color: #e2b714;
        }

        .test-area {
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
            cursor: text;
        }

        .word-display {
            background: #2c2e31;
            padding: 30px;
            border-radius: 8px;
            font-size: 1.8rem;
            line-height: 2.2;
            height: auto;
            max-height: calc( (1.8rem * 2.2) * 5 + 60px ); /* æœ€å¤§5è¡Œåˆ† + padding ã§ã‚¯ãƒ©ãƒ³ãƒ— */
            border: 2px solid transparent;
            transition: border-color 0.2s, height 0.2s ease;
            overflow: hidden;
            position: relative;
        }


        /* å¤‰æ›´: wordStream ã‚’çµ¶å¯¾é…ç½®ã‹ã‚‰ç›¸å¯¾é…ç½®ã¸ã—ã€æŠ˜ã‚Šè¿”ã—ã‚’æœ‰åŠ¹ã«ã™ã‚‹ */
        #wordStream {
            position: relative; /* absolute -> relative ã«å¤‰æ›´ */
            width: 100%;
            transition: transform 0.3s ease-in-out;
            white-space: normal; /* æŠ˜ã‚Šè¿”ã—æœ‰åŠ¹åŒ– */
            word-break: break-word;
            display: block; /* å„ .word ã¯ inline-block ã®ã¾ã¾æŠ˜ã‚Šè¿”ã•ã‚Œã‚‹ */
        }

        /* word-display ã®é«˜ã•ã¯ JS ã§å‹•çš„ã«æ±ºã‚ã‚‹ãŸã‚ min/max ã‚’æŒ‡å®šã—ã¦ãŠã */
        .word-display {
            background: #2c2e31;
            padding: 30px;
            border-radius: 8px;
            font-size: 1.8rem;
            line-height: 2.2;
            /* å›ºå®šé«˜ã•ã® calc() ã‚’å‰Šé™¤ã—ã¦è‡ªå‹•ã«ã€‚JS ã§ height ã‚’ä¸Šæ›¸ãã—ã¾ã™ */
            height: auto;
            max-height: 80vh; /* æ¥µç«¯ã«å¤§ãããªã‚‰ãªã„ã‚ˆã†ã«ä¸Šé™ã‚’è¨­å®š */
            border: 2px solid transparent;
            transition: border-color 0.2s, height 0.2s ease;
            overflow: hidden;
            position: relative;
        }

        /* å„ãƒ¯ãƒ¼ãƒ‰è¦ç´ ãŒæ ã®å³ã«ã¯ã¿å‡ºã™ã“ã¨ã‚’é˜²ã */
        .word {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            transition: color 0.2s;
            max-width: 100%;
            box-sizing: border-box;
            margin-right: 8px; /* å˜èªã®å³å´ã«8pxã®ä½™ç™½ã‚’è¿½åŠ  */
        }


        .word.current {
            color: #e2b714;
        }

        .kana-display {
            font-size: 1.4rem;
            color: #d1d0c5;
            margin-top: 15px;
            height: 2.5em;
            text-align: center;
            letter-spacing: 2px;
            background: #2c2e31;
            padding: 10px;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .kana-stream {
            position: absolute;
            top: 10px; /* Same as padding */
            left: 50%;
            white-space: nowrap;
        }

        .kana-stream .typed {
            color: #646669;
        }
        .kana-stream .untyped {
            opacity: 1;
        }

        #cursor {
            display: inline-block;
            background-color: #e2b714;
            width: 2px;
            height: 1.4rem;
            vertical-align: middle;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
        }

        .stat {
            text-align: center;
            min-width: 80px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #e2b714;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #646669;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .results {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .results.show {
            display: flex;
        }

        .results-content {
            background: #2c2e31;
            padding: 40px;
            border-radius: 8px;
            text-align: center;
            width: 90%;
            max-width: 600px;
        }

        .results h2 {
            color: #e2b714;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .restart-btn {
            background: #e2b714;
            color: #323437;
            font-weight: bold;
            padding: 12px 24px;
            font-size: 1.1rem;
        }

        .restart-btn:hover {
            background: #f4c430;
            border-color: #f4c430;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #646669;
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #e2b714;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* --- Level Chart Styles --- */
        .level-chart {
            max-width: 800px;
            width: 100%;
            margin-top: 60px;
            padding-bottom: 40px;
            text-align: center;
        }

        .level-chart h2 {
            color: #e2b714;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 300;
        }

        .level-chart table {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .level-chart th, .level-chart td {
            padding: 12px 15px;
            border: 1px solid #646669;
        }

        .level-chart th {
            background-color: #2c2e31;
            color: #e2b714;
            font-weight: bold;
        }

        .level-chart tr:nth-child(even) {
            background-color: #2c2e31;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">æ—¥æœ¬èªã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’</h1>
        <p class="subtitle">Japanese Typing Practice</p>
    </div>
    <div id="bestRecord" style="margin-top:12px; text-align:center; color:#d1d0c5; font-size:0.95rem;">
      ãƒ™ã‚¹ãƒˆ: - (å˜èª:- / KPM:- / KPS:-)
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="wordCountSelect">å˜èªæ•°:</label>
            <select id="wordCountSelect">
                <option value="15">15</option>
                <option value="30" selected>30</option>
                <option value="50">50</option>
                <option value="100">100</option>
            </select>
            <input type="number" id="customWordCount" class="custom-input" placeholder="ã‚«ã‚¹ã‚¿ãƒ " min="1">
        </div>
        
        <div class="control-group">
            <label for="timeLimitSelect">æ™‚é–“(ç§’):</label>
            <select id="timeLimitSelect">
                <option value="30">30</option>
                <option value="60" selected>60</option>
                <option value="120">120</option>
                <option value="0">ç„¡åˆ¶é™</option>
            </select>
            <input type="number" id="customTimeLimit" class="custom-input" placeholder="ã‚«ã‚¹ã‚¿ãƒ " min="0">
        </div>

        <div class="control-group">
            <input type="checkbox" id="spaceToggle" checked>
            <label for="spaceToggle">ã‚¹ãƒšãƒ¼ã‚¹å…¥åŠ›ã‚’å¿…é ˆã«ã™ã‚‹</label>
        </div>
        
        <button id="restartBtn">å†ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <div class="test-area" id="testArea">
        <div id="wordDisplay" class="word-display">
            <div id="wordStream"></div>
        </div>
        <div id="kanaDisplay" class="kana-display">
            <div id="kanaStream" class="kana-stream"></div>
        </div>
        <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>
    </div>

    <div class="stats">
        <div class="stat">
            <span id="kpm" class="stat-value">0</span>
            <span class="stat-label">KPM</span>
        </div>
        <div class="stat">
            <span id="kps" class="stat-value">0.00</span>
            <span class="stat-label">KPS</span>
        </div>
        <div class="stat">
            <span id="accuracy" class="stat-value">100%</span>
            <span class="stat-label">æ­£ç¢ºæ€§</span>
        </div>
        <div class="stat">
            <span id="timer" class="stat-value">60</span>
            <span class="stat-label">æ™‚é–“</span>
        </div>
    </div>

    <!-- Level Chart Section -->
    <div class="level-chart">
        <h2>ãƒ¬ãƒ™ãƒ«ä¸€è¦§</h2>
        <table id="levelTable">
            <thead>
                <tr>
                    <th>Level</th>
                    <th>KPM (ã‚­ãƒ¼æ¯åˆ†)</th>
                </tr>
            </thead>
            <tbody>
                <!-- JSã§ç”Ÿæˆã•ã‚Œã¾ã™ -->
            </tbody>
        </table>
    </div>

    <div id="results" class="results">
        <div class="results-content">
            <h2>çµæœ</h2>
            <div class="results-grid">
                <div class="stat">
                    <span id="finalLevel" class="stat-value">-</span>
                    <span class="stat-label">Level</span>
                </div>
                <div class="stat">
                    <span id="finalKPM" class="stat-value">0</span>
                    <span class="stat-label">KPM</span>
                </div>
                <div class="stat">
                    <span id="finalKPS" class="stat-value">0.00</span>
                    <span class="stat-label">KPS</span>
                </div>
                <div class="stat">
                    <span id="finalAccuracy" class="stat-value">100%</span>
                    <span class="stat-label">æ­£ç¢ºæ€§</span>
                </div>
                <div class="stat">
                    <span id="finalTime" class="stat-value">0</span>
                    <span class="stat-label">çµŒéæ™‚é–“</span>
                </div>
            </div>
            <button id="restartBtnResults" class="restart-btn">ã‚‚ã†ä¸€åº¦</button>
        </div>
    </div>

    <script>
    (async () => {
        // --- Logic from typing.ts (transpiled to JS) ---
        class ChunkPattern {
        }
        ChunkPattern.list = new Map([
            ["ã‚", [["a"]]], ["ã„", [["i"], ["yi"]]], ["ã†", [["u"], ["wu"], ["whu"]]], ["ãˆ", [["e"]]], ["ãŠ", [["o"]]],
            ["ã†ã", [["wha"]]], ["ã†ãƒ", [["wi"], ["whi"]]], ["ã†ã‡", [["we"], ["whe"]]], ["ã†ã‰", [["who"]]],
            ["ã‚", [["wi"]]], ["ã‚‘", [["we"]]], ["ã", [["la"], ["xa"]]], ["ãƒ", [["li"], ["xi"], ["lyi"], ["xyi"]]], ["ã…", [["lu"], ["xu"]]], ["ã‡", [["le"], ["xe"], ["lye"], ["xye"]]], ["ã‰", [["lo"], ["xo"]]],
            ["ãƒã‡", [["ye"]]], ["ã‹", [["ka"], ["ca"]]], ["ã", [["ki"]]], ["ã", [["ku"], ["cu"], ["qu"]]], ["ã‘", [["ke"]]], ["ã“", [["ko"], ["co"]]],
            ["ãã‚ƒ", [["kya"]]], ["ããƒ", [["kyi"]]], ["ãã‚…", [["kyu"]]], ["ãã‡", [["kye"]]], ["ãã‚‡", [["kyo"]]],
            ["ãã‚ƒ", [["qya"]]], ["ãã‚…", [["qyu"]]], ["ãã‚‡", [["qyo"]]], ["ãã", [["qa"], ["qwa"], ["kwa"]]], ["ããƒ", [["qi"], ["qwi"], ["qyi"]]], ["ãã…", [["qwu"]]], ["ãã‡", [["qe"], ["qwe"], ["qye"]]], ["ãã‰", [["qo"], ["qwo"]]],
            ["ãŒ", [["ga"]]], ["ã", [["gi"]]], ["ã", [["gu"]]], ["ã’", [["ge"]]], ["ã”", [["go"]]],
            ["ãã‚ƒ", [["gya"]]], ["ããƒ", [["gyi"]]], ["ãã‚…", [["gyu"]]], ["ãã‡", [["gye"]]], ["ãã‚‡", [["gyo"]]],
            ["ãã", [["gwa"]]], ["ããƒ", [["gwi"]]], ["ãã…", [["gwu"]]], ["ãã‡", [["gwe"]]], ["ãã‰", [["gwo"]]],
            ["ãƒµ", [["lka"], ["xka"]]], ["ãƒ¶", [["lke"], ["xke"]]], ["ã•", [["sa"]]], ["ã—", [["si"], ["ci"], ["shi"]]], ["ã™", [["su"]]], ["ã›", [["se"], ["ce"]]], ["ã", [["so"]]],
            ["ã—ã‚ƒ", [["sya"], ["sha"]]], ["ã—ãƒ", [["syi"]]], ["ã—ã‚…", [["syu"], ["shu"]]], ["ã—ã‡", [["sye"], ["she"]]], ["ã—ã‚‡", [["syo"], ["sho"]]],
            ["ã™ã", [["swa"]]], ["ã™ãƒ", [["swi"]]], ["ã™ã…", [["swu"]]], ["ã™ã‡", [["swe"]]], ["ã™ã‰", [["swo"]]],
            ["ã–", [["za"]]], ["ã˜", [["zi"], ["ji"]]], ["ãš", [["zu"]]], ["ãœ", [["ze"]]], ["ã", [["zo"]]],
            ["ã˜ã‚ƒ", [["ja"], ["zya"], ["jya"]]], ["ã˜ãƒ", [["zyi"], ["jyi"]]], ["ã˜ã‚…", [["ju"], ["zyu"], ["jyu"]]], ["ã˜ã‡", [["je"], ["zye"], ["jye"]]], ["ã˜ã‚‡", [["jo"], ["zyo"], ["jyo"]]],
            ["ãŸ", [["ta"]]], ["ã¡", [["ti"], ["chi"]]], ["ã¤", [["tu"], ["tsu"]]], ["ã¦", [["te"]]], ["ã¨", [["to"]]],
            ["ã¡ã‚ƒ", [["tya"], ["cha"], ["cya"]]], ["ã¡ãƒ", [["tyi"], ["cyi"]]], ["ã¡ã‚…", [["tyu"], ["chu"], ["cyu"]]], ["ã¡ã‡", [["tye"], ["che"], ["cye"]]], ["ã¡ã‚‡", [["tyo"], ["cho"], ["cyo"]]],
            ["ã¤ã", [["tsa"]]], ["ã¤ãƒ", [["tsi"]]], ["ã¤ã‡", [["tse"]]], ["ã¤ã‰", [["tso"]]],
            ["ã¦ã‚ƒ", [["tha"]]], ["ã¦ãƒ", [["thi"]]], ["ã¦ã‚…", [["thu"]]], ["ã¦ã‡", [["the"]]], ["ã¦ã‚‡", [["tho"]]],
            ["ã¨ã", [["twa"]]], ["ã¨ãƒ", [["twi"]]], ["ã¨ã…", [["twu"]]], ["ã¨ã‡", [["twe"]]], ["ã¨ã‰", [["two"]]],
            ["ã ", [["da"]]], ["ã¢", [["di"]]], ["ã¥", [["du"]]], ["ã§", [["de"]]], ["ã©", [["do"]]],
            ["ã¢ã‚ƒ", [["dya"]]], ["ã¢ãƒ", [["dyi"]]], ["ã¢ã‚…", [["dyu"]]], ["ã¢ã‡", [["dye"]]], ["ã¢ã‚‡", [["dyo"]]],
            ["ã§ã‚ƒ", [["dha"]]], ["ã§ãƒ", [["dhi"]]], ["ã§ã‚…", [["dhu"]]], ["ã§ã‡", [["dhe"]]], ["ã§ã‚‡", [["dho"]]],
            ["ã©ã", [["dwa"]]], ["ã©ãƒ", [["dwi"]]], ["ã©ã…", [["dwu"]]], ["ã©ã‡", [["dwe"]]], ["ã©ã‰", [["dwo"]]],
            ["ã£", [["ltu"], ["xtu"], ["ltsu"], ["xtsu"]]], ["ãª", [["na"]]], ["ã«", [["ni"]]], ["ã¬", [["nu"]]], ["ã­", [["ne"]]], ["ã®", [["no"]]],
            ["ã«ã‚ƒ", [["nya"]]], ["ã«ãƒ", [["nyi"]]], ["ã«ã‚…", [["nyu"]]], ["ã«ã‡", [["nye"]]], ["ã«ã‚‡", [["nyo"]]],
            ["ã¯", [["ha"]]], ["ã²", [["hi"]]], ["ãµ", [["hu"], ["fu"]]], ["ã¸", [["he"]]], ["ã»", [["ho"]]],
            ["ã²ã‚ƒ", [["hya"]]], ["ã²ãƒ", [["hyi"]]], ["ã²ã‚…", [["hyu"]]], ["ã²ã‡", [["hye"]]], ["ã²ã‚‡", [["hyo"]]],
            ["ãµã", [["fa"], ["fwa"]]], ["ãµãƒ", [["fi"], ["fwi"], ["fyi"]]], ["ãµã…", [["fwu"]]], ["ãµã‡", [["fe"], ["fwe"], ["fye"]]], ["ãµã‰", [["fo"], ["fwo"]]],
            ["ãµã‚ƒ", [["fya"]]], ["ãµã‚…", [["fyu"]]], ["ãµã‚‡", [["fyo"]]], ["ã°", [["ba"]]], ["ã³", [["bi"]]], ["ã¶", [["bu"]]], ["ã¹", [["be"]]], ["ã¼", [["bo"]]],
            ["ã³ã‚ƒ", [["bya"]]], ["ã³ãƒ", [["byi"]]], ["ã³ã‚…", [["byu"]]], ["ã³ã‡", [["bye"]]], ["ã³ã‚‡", [["byo"]]],
            ["ãƒ´ã", [["va"]]], ["ãƒ´ãƒ", [["vi"]]], ["ãƒ´", [["vu"]]], ["ãƒ´ã‡", [["ve"]]], ["ãƒ´ã‰", [["vo"]]],
            ["ãƒ´ã‚ƒ", [["vya"]]], ["ãƒ´ãƒ", [["vyi"]]], ["ãƒ´ã‚…", [["vyu"]]], ["ãƒ´ã‡", [["vye"]]], ["ãƒ´ã‚‡", [["vyo"]]],
            ["ã±", [["pa"]]], ["ã´", [["pi"]]], ["ã·", [["pu"]]], ["ãº", [["pe"]]], ["ã½", [["po"]]],
            ["ã´ã‚ƒ", [["pya"]]], ["ã´ãƒ", [["pyi"]]], ["ã´ã‚…", [["pyu"]]], ["ã´ã‡", [["pye"]]], ["ã´ã‚‡", [["pyo"]]],
            ["ã¾", [["ma"]]], ["ã¿", [["mi"]]], ["ã‚€", [["mu"]]], ["ã‚", [["me"]]], ["ã‚‚", [["mo"]]],
            ["ã¿ã‚ƒ", [["mya"]]], ["ã¿ãƒ", [["myi"]]], ["ã¿ã‚…", [["myu"]]], ["ã¿ã‡", [["mye"]]], ["ã¿ã‚‡", [["myo"]]],
            ["ã‚„", [["ya"]]], ["ã‚†", [["yu"]]], ["ã‚ˆ", [["yo"]]], ["ã‚ƒ", [["lya"], ["xya"]]], ["ã‚…", [["lyu"], ["xyu"]]], ["ã‚‡", [["lyo"], ["xyo"]]],
            ["ã‚‰", [["ra"]]], ["ã‚Š", [["ri"]]], ["ã‚‹", [["ru"]]], ["ã‚Œ", [["re"]]], ["ã‚", [["ro"]]],
            ["ã‚Šã‚ƒ", [["rya"]]], ["ã‚Šãƒ", [["ryi"]]], ["ã‚Šã‚…", [["ryu"]]], ["ã‚Šã‡", [["rye"]]], ["ã‚Šã‚‡", [["ryo"]]],
            ["ã‚", [["wa"]]], ["ã‚’", [["wo"]]], ["ã‚“", [["n"], ["nn"], ["n'"], ["xn"]]], ["ã‚", [["lwa"], ["xwa"]]], ["ãƒ¼", [["-"]]], ["ã€€", [[" "]]]
        ]);
        ChunkPattern._initialize = (() => {
            for (const chunkPattern of ChunkPattern.list) {
                const kana = chunkPattern[0];
                if (kana.length >= 2) {
                    let multiPattern = [];
                    for (const c of kana) {
                        if (multiPattern.length === 0) {
                            multiPattern = ChunkPattern.list.get(c);
                        }
                        else {
                            const tmp = [];
                            for (const p1 of multiPattern) {
                                for (const p2 of ChunkPattern.list.get(c)) {
                                    tmp.push(p1.concat(p2));
                                }
                            }
                            multiPattern = tmp;
                        }
                    }
                    ChunkPattern.list.set(kana, chunkPattern[1].concat(multiPattern));
                }
            }
        })();

        function devideIntoChunk(kana) {
            const ret = [];
            for (let i = 0; i < kana.length; ++i) {
                if (i >= kana.length - 1) {
                    ret.push(new Chunk(kana[i]));
                    break;
                }
                if (kana[i] !== "ã£" && kana[i] !== "ã‚“") {
                    if (!ChunkPattern.list.has(kana[i] + kana[i + 1])) {
                        ret.push(new Chunk(kana[i]));
                    }
                    else {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        ++i;
                    }
                }
                else {
                    if (i >= kana.length - 2) {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        break;
                    }
                    if (!ChunkPattern.list.has(kana[i + 1] + kana[i + 2])) {
                        ret.push(new Chunk(kana[i] + kana[i + 1]));
                        ++i;
                    }
                    else {
                        ret.push(new Chunk(kana[i] + kana[i + 1] + kana[i + 2]));
                        i += 2;
                    }
                }
            }
            return ret;
        }

        class TypePattern {
            constructor(romanList) {
                this._isValid = true;
                this._romanCount = 0;
                this._curKanaRomanIndex = 0;
                this._curKanaRomanCount = 0;
                this._kanaRomanList = romanList;
                this._roman = romanList.join("");
            }
                        getCurChar() {
                // å®‰å…¨ã«ç¾åœ¨ã®ãƒ­ãƒ¼ãƒ1æ–‡å­—ã‚’è¿”ã™ã€‚ç„¡ã‘ã‚Œã°ç©ºæ–‡å­—ã€‚
                return this._roman[this._romanCount] || '';
            }

            increment(kanaFinished) {
                ++this._romanCount;
                ++this._curKanaRomanCount;
                if (this._curKanaRomanCount >= this._curKanaRoman.length) {
                    ++this._curKanaRomanIndex;
                    this._curKanaRomanCount = 0;
                    kanaFinished(this._curKanaRomanIndex);
                }
            }
            get _curKanaRoman() {
                return this._kanaRomanList[this._curKanaRomanIndex];
            }
            get isValid() {
                return this._isValid;
            }
            isChunkFinished() {
                return this._romanCount >= this._roman.length;
            }
            invalidate() {
                this._isValid = false;
            }
        }

        class TypePatternList {
            constructor(romanLists) {
                this._displayPatternNum = 0;
                this._isChunkFinished = false;
                this._additionalRomanCount = 0;
                this._typePatternList = romanLists.map((romanList) => new TypePattern(romanList));
            }
            isCorrectInput(inputChar) {
                for (const typePattern of this._typePatternList) {
                    if (typePattern.isValid && typePattern.getCurChar() === inputChar)
                        return true;
                }
                return false;
            }
            update(inputChar, kanaFinished) {
                if (!this.isCorrectInput(inputChar)) {
                    return false;
                }
                for (const typePattern of this._typePatternList) {
                    if (!typePattern.isValid)
                        continue;
                    if (inputChar === typePattern.getCurChar()) {
                        typePattern.increment(kanaFinished);
                        if (typePattern.isChunkFinished()) {
                            this._isChunkFinished = true;
                            continue;
                        }
                    }
                    else {
                        if (typePattern === this._typePatternList[this._displayPatternNum]) {
                            this._displayPatternNum = -1;
                        }
                        typePattern.invalidate();
                    }
                }
                if (this._displayPatternNum === -1) {
                    for (let i = 0; i < this._typePatternList.length; ++i) {
                        if (this._typePatternList[i].isValid) {
                            this._displayPatternNum = i;
                            break;
                        }
                    }
                }
                return true;
            }
            get isChunkFinished() {
                return this._isChunkFinished;
            }
        }

        class Chunk {
            constructor(kana) {
                this._kanaCount = 0;
                this._xtuVowels = ["a", "i", "u", "e", "o", "n"];
                this._xnVowels = this._xtuVowels.concat(["y"]);
                this._kana = kana;
                if (!ChunkPattern.list.has(kana)) {
                    // This case handles combined chunks like 'ã‚“ã€€'
                    if (kana.length > 1 && ChunkPattern.list.has(kana[0]) && ChunkPattern.list.has(kana.substr(1))) {
                         const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        const xnPatterns = ChunkPattern.list.get(kana[0]); // Assuming the first char is special (like 'ã‚“')
                        for (const roman of curPatterns) {
                            for (const xn of xnPatterns) {
                                if (xn[0] !== "n") {
                                    newPatterns.push(xn.concat(roman));
                                }
                                else {
                                    if (!this._xnVowels.includes(roman[0][0])) {
                                        newPatterns.push(xn.concat(roman));
                                    }
                                }
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    } else {
                        this._typePatternList = new TypePatternList([[]]); // Empty/invalid
                    }
                } else if (kana.length == 1) {
                    this._typePatternList = new TypePatternList(ChunkPattern.list.get(kana));
                }
                else {
                    if (kana[0] === "ã£") {
                        const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        for (const roman of curPatterns) {
                            const romanFirstChar = roman[0][0];
                            if (!this._xtuVowels.includes(romanFirstChar)) {
                                newPatterns.push([romanFirstChar].concat(roman));
                            }
                        }
                        for (const roman of curPatterns) {
                            for (const xtu of ChunkPattern.list.get("ã£")) {
                                newPatterns.push(xtu.concat(roman));
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    }
                    else if (kana[0] === "ã‚“") {
                        const curPatterns = ChunkPattern.list.get(kana.substr(1));
                        const newPatterns = [];
                        const xnPatterns = ChunkPattern.list.get("ã‚“");
                        for (const roman of curPatterns) {
                            for (const xn of xnPatterns) {
                                if (xn[0] !== "n") {
                                    newPatterns.push(xn.concat(roman));
                                }
                                else {
                                    if (!this._xnVowels.includes(roman[0][0])) {
                                        newPatterns.push(xn.concat(roman));
                                    }
                                }
                            }
                        }
                        this._typePatternList = new TypePatternList(newPatterns);
                    }
                    else {
                        this._typePatternList = new TypePatternList(ChunkPattern.list.get(kana));
                    }
                }
            }
            update(inputChar) {
                const kanaFinished = (newKanaCount) => {
                    this._kanaCount = newKanaCount;
                };
                const ret = this._typePatternList.update(inputChar, kanaFinished);
                if (this._typePatternList.isChunkFinished) {
                    this._kanaCount = this._kana.length;
                }
                return ret;
            }
            get kanaCount() {
                return this._kanaCount;
            }
            get isChunkFinished() {
                return this._typePatternList.isChunkFinished;
            }
            get kana() {
                return this._kana;
            }
        }

        class WordTyper {
            constructor(kana) {
                this.kana = kana;
                this.chunks = devideIntoChunk(kana);
                this.chunkIndex = 0;
            }

                                    update(key) {
                if (this.isFinished()) return { isCorrect: false };

                const currentChunk = this.chunks[this.chunkIndex];
                // æ™®é€šã®æ›´æ–°ã‚’ã¾ãšè©¦ã™
                let isCorrect = currentChunk.update(key);

                // ã‚‚ã—é€šå¸¸æ›´æ–°ã§ä¸æ­£ã¨åˆ¤å®šã•ã‚Œã€ã‹ã¤ç¾åœ¨ãƒãƒ£ãƒ³ã‚¯ãŒä¿ƒéŸ³ï¼ˆã£ï¼‰ã‚’å…ˆé ­ã«æŒã¤ã¨ãã€
                // æ¬¡ãƒãƒ£ãƒ³ã‚¯ã®æœŸå¾…ã™ã‚‹å…ˆé ­æ–‡å­—ãŒä»Šå›ã®å…¥åŠ›ã‚­ãƒ¼ã¨ä¸€è‡´ã™ã‚Œã°ä¿ƒéŸ³å‡¦ç†ã‚’å¼·åˆ¶ã™ã‚‹
                if (!isCorrect) {
                    const nextChunk = this.chunks[this.chunkIndex + 1];
                    if (currentChunk && typeof currentChunk.kana === 'string' && currentChunk.kana[0] === 'ã£' && nextChunk) {
                        try {
                            const tplContainer = nextChunk._typePatternList;
                            const tpl = tplContainer && tplContainer._typePatternList;
                            if (tpl && tpl.length > 0) {
                                // nextChunk ã®ã„ãšã‚Œã‹ã® TypePattern ãŒç¾åœ¨æœŸå¾…ã—ã¦ã„ã‚‹æ–‡å­—ï¼ˆgetCurCharï¼‰ãŒ key ã¨ä¸€è‡´ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚‹
                                let matchNextFirstChar = false;
                                for (const tp of tpl) {
                                    const c = (tp.getCurChar && tp.getCurChar()) || '';
                                    if (c === key) {
                                        matchNextFirstChar = true;
                                        break;
                                    }
                                }
                                if (matchNextFirstChar) {
                                    // --- ã“ã“ã§ä¿ƒéŸ³ãƒãƒ£ãƒ³ã‚¯ã‚’å¼·åˆ¶çš„ã«å®Œäº†æ‰±ã„ã«ã™ã‚‹ ---
                                    // currentChunk._kanaCount ã‚’ç›´æ¥æ“ä½œã—ã¦ä¿ƒéŸ³ã‚’å®Œäº†ã•ã›ã‚‹
                                    // ï¼ˆChunk ã‚¯ãƒ©ã‚¹ã®ã‚²ãƒƒã‚¿ãƒ¼ã¯ kanaCount ã‚’å‚ç…§ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã‚Œã§å®Œäº†æ‰±ã„ã«ãªã‚‹ï¼‰
                                    try {
                                        currentChunk._kanaCount = currentChunk._kana.length;
                                    } catch (e) {
                                        // ä½•ã‹å¤±æ•—ã—ã¦ã‚‚å…ˆã«é€²ã‚ãªã„ã ã‘ãªã®ã§ç„¡è¦–
                                    }
                                    // chunkIndex ã‚’é€²ã‚ã¦æ¬¡ãƒãƒ£ãƒ³ã‚¯ã«ç§»ã‚‹
                                    this.chunkIndex++;

                                    // åŒã˜ key ã‚’æ¬¡ãƒãƒ£ãƒ³ã‚¯ã¸å†å¸°çš„ã«é©ç”¨ã—ã¦æ¶ˆè²»ã•ã›ã‚‹
                                    if (!this.isFinished()) {
                                        return this.update(key);
                                    } else {
                                        // æ¬¡ãƒãƒ£ãƒ³ã‚¯ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æˆåŠŸæ‰±ã„ã«ã™ã‚‹
                                        return { isCorrect: true, isFinished: this.isFinished() };
                                    }
                                }
                            }
                        } catch (err) {
                            // å†…éƒ¨ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ãŸå ´åˆã¯é€šå¸¸ã®ä¸æ­£æ‰±ã„ã«è½ã¨ã™
                        }
                    }
                }

                // currentChunk ãŒå®Œäº†ã—ã¦ã„ã‚Œã° index ã‚’é€²ã‚ã‚‹ï¼ˆé€šå¸¸çµŒè·¯ï¼‰
                if (currentChunk.isChunkFinished) {
                    this.chunkIndex++;
                }

                return {
                    isCorrect,
                    isFinished: this.isFinished(),
                };
            }



            isFinished() {
                return this.chunkIndex >= this.chunks.length;
            }
            
            getTypedKana() {
                if (this.isFinished()) return this.kana;
                const completedKana = this.chunks.slice(0, this.chunkIndex).map(c => c.kana).join('');
                const partialChunk = this.chunks[this.chunkIndex];
                const partialKana = partialChunk ? partialChunk.kana.substring(0, partialChunk.kanaCount) : '';
                return completedKana + partialKana;
            }
        }

        const levelMap = [
            { level: 'ZZ', kpm: 4000 }, { level: 'ZX', kpm: 3000 }, { level: 'ZS', kpm: 2400 },
            { level: 'ZA', kpm: 2000 }, { level: 'ZB', kpm: 1714.29 }, { level: 'ZC', kpm: 1500 },
            { level: 'ZD', kpm: 1333.33 }, { level: 'ZE', kpm: 1200 }, { level: 'ZF', kpm: 1090.91 },
            { level: 'ZG', kpm: 1000 }, { level: 'ZH', kpm: 923.08 }, { level: 'ZI', kpm: 857.14 },
            { level: 'ZJ', kpm: 800 }, { level: 'XX', kpm: 750 }, { level: 'XS', kpm: 705.88 },
            { level: 'XA', kpm: 666.67 }, { level: 'XB', kpm: 631.58 }, { level: 'XC', kpm: 600 },
            { level: 'XD', kpm: 571.43 }, { level: 'XE', kpm: 545.45 }, { level: 'XF', kpm: 521.74 },
            { level: 'XG', kpm: 500 }, { level: 'XH', kpm: 480 }, { level: 'XI', kpm: 461.54 },
            { level: 'XJ', kpm: 444.44 }, { level: 'SS', kpm: 428.57 }, { level: 'SA', kpm: 413.79 },
            { level: 'SB', kpm: 400 }, { level: 'SC', kpm: 387.10 }, { level: 'SD', kpm: 375 },
            { level: 'SE', kpm: 363.64 }, { level: 'SF', kpm: 352.94 }, { level: 'SG', kpm: 342.86 },
            { level: 'SH', kpm: 333.33 }, { level: 'SI', kpm: 324.32 }, { level: 'SJ', kpm: 315.79 },
            { level: 'A', kpm: 300 }, { level: 'B', kpm: 279.07 }, { level: 'C', kpm: 255.32 },
            { level: 'D', kpm: 230.77 }, { level: 'E', kpm: 206.90 }, { level: 'F', kpm: 184.62 },
            { level: 'G', kpm: 164.38 }, { level: 'H', kpm: 146.34 }, { level: 'I', kpm: 130.43 },
            { level: 'J', kpm: 116.50 }
        ];

        function getLevel(kpm) {
            for (const item of levelMap) {
                if (kpm >= item.kpm) {
                    return item.level;
                }
            }
            return '-';
        }

        class TypingTest {
            // --- Best record save/load (localStorage) ---
const BEST_RECORD_KEY = 'typingBestRecordV1';

function loadBestRecord() {
    try {
        const raw = localStorage.getItem(BEST_RECORD_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (obj && typeof obj.kpm === 'number') return obj;
        return null;
    } catch (e) {
        return null;
    }
}

function saveBestRecord(record) {
    try {
        localStorage.setItem(BEST_RECORD_KEY, JSON.stringify(record));
    } catch (e) {
        // ä¿å­˜ã§ããªã„å ´åˆã¯ç„¡è¦–
    }
}

function formatBestRecordText(record) {
    if (!record) return 'ãƒ™ã‚¹ãƒˆ: - (å˜èª:- / KPM:- / KPS:-)';
    return `ãƒ™ã‚¹ãƒˆ: ${record.level} (å˜èª:${record.wordCount} / KPM:${Math.round(record.kpm)} / KPS:${record.kps.toFixed(2)})`;
}

function renderBestRecord() {
    const el = document.getElementById('bestRecord');
    if (!el) return;
    const best = loadBestRecord();
    el.textContent = formatBestRecordText(best);
}

// æ›´æ–°åˆ¤å®š: ã‚ˆã‚Šé«˜ã„ kpm ã‚’ä¸Šä½ã¨ã™ã‚‹ã€‚kpm ãŒåŒã˜ãªã‚‰ kps ã‚’æ¯”è¼ƒã€‚
function isBetterRecord(current, best) {
    if (!best) return true;
    if (current.kpm > best.kpm) return true;
    if (current.kpm === best.kpm && current.kps > best.kps) return true;
    return false;
}

// --- TypingTest.showResults å†…ã§å‘¼ã³å‡ºã™è£œåŠ©é–¢æ•° ---
// currentRecord ã¯ { level, wordCount, kpm, kps, accuracy, elapsedSeconds, timestamp }
function tryUpdateBestRecord(currentRecord) {
    const best = loadBestRecord();
    if (isBetterRecord(currentRecord, best)) {
        saveBestRecord(currentRecord);
        renderBestRecord();
        // ç°¡å˜ãªè¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆresults ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã«çŸ­ãè¡¨ç¤ºï¼‰
        const note = document.createElement('div');
        note.style.marginTop = '8px';
        note.style.color = '#e2b714';
        note.textContent = 'New Best! ğŸ‰';
        const resultsContent = document.querySelector('.results-content');
        if (resultsContent) resultsContent.appendChild(note);
    }
}

            constructor(wordsData) {
                this.allWords = wordsData;
                this.initGame();
                this.initElements();
                this.initEventListeners();
                this.restart();
            }

            initGame() {
                this.words = [];
                this.wordBoundaries = [];
                this.fullKanaString = '';
                this.wordTyper = null;
                this.correctTypedKeys = 0;
                this.incorrectChars = 0;
                this.totalTypedChars = 0;
                this.startTime = null;
                this.endTime = null;
                this.timer = null;
                this.timeLeft = 60;
                this.isActive = false;
                this.isCompleted = false;
                this.lastScrolledLine = -1;
            }

            initElements() {
                this.testArea = document.getElementById('testArea');
                this.wordDisplay = document.getElementById('wordDisplay');
                this.wordStream = document.getElementById('wordStream');
                this.kanaDisplay = document.getElementById('kanaDisplay');
                this.kanaStream = document.getElementById('kanaStream');
                this.kpmElement = document.getElementById('kpm');
                this.kpsElement = document.getElementById('kps');
                this.accuracyElement = document.getElementById('accuracy');
                this.timerElement = document.getElementById('timer');
                this.results = document.getElementById('results');
                this.wordCountSelect = document.getElementById('wordCountSelect');
                this.customWordCount = document.getElementById('customWordCount');
                this.timeLimitSelect = document.getElementById('timeLimitSelect');
                this.customTimeLimit = document.getElementById('customTimeLimit');
                this.spaceToggle = document.getElementById('spaceToggle');
                this.restartBtn = document.getElementById('restartBtn');
                this.restartBtnResults = document.getElementById('restartBtnResults');
                this.progressFill = document.getElementById('progressFill');
            }

            initEventListeners() {
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                this.testArea.addEventListener('click', () => this.startTest());
                this.restartBtn.addEventListener('click', () => this.restart());
                this.restartBtnResults.addEventListener('click', () => this.restart());
                this.wordCountSelect.addEventListener('change', () => this.restart());
                this.customWordCount.addEventListener('change', () => this.restart());
                this.timeLimitSelect.addEventListener('change', () => this.restart());
                this.customTimeLimit.addEventListener('change', () => this.restart());
                this.spaceToggle.addEventListener('change', () => this.restart());
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã£ãŸã‚‰è¡Œæ•°å†è¨ˆç®—ã¨é«˜ã•èª¿æ•´ã‚’è¡Œã†
                window.addEventListener('resize', () => {
                    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå¤‰ã‚ã‚‹ãŸã‚è¡Œå‰²ã‚Šã‚’å†è¨ˆç®—ã—ã¦é«˜ã•ã‚’å†è¨­å®š
                    this.calculateLines();
                    this.adjustWordDisplayHeight();
                });

            }

            getWordCount() {
                const customCount = parseInt(this.customWordCount.value);
                if (!isNaN(customCount) && customCount > 0) {
                    return customCount;
                }
                return parseInt(this.wordCountSelect.value);
            }

            getTimeLimit() {
                const customTime = parseInt(this.customTimeLimit.value);
                if (!isNaN(customTime) && customTime >= 0) {
                    return customTime;
                }
                return parseInt(this.timeLimitSelect.value);
            }

            // --- ä¿®æ­£ç®‡æ‰€: handleKeyDownãƒ¡ã‚½ãƒƒãƒ‰å…¨ä½“ã‚’æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ã«ç½®ãæ›ãˆ ---
            handleKeyDown(e) {
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'SELECT') {
                    return;
                }

                if (e.key === 'Escape') {
                    this.restart();
                    return;
                }
                if (this.isCompleted) return;
                if (e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta') return;
                if (e.ctrlKey || e.metaKey) return;

                e.preventDefault();

                if (!this.isActive) {
                    this.startTest();
                }
                
                if (e.key === 'Backspace') {
                    return; // ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã¯ã‚µãƒãƒ¼ãƒˆã—ãªã„
                }

                // ã‚¹ãƒšãƒ¼ã‚¹å¿…é ˆãŒã‚ªãƒ•ã®å ´åˆã€ã‚¹ãƒšãƒ¼ã‚¹å…¥åŠ›ã‚’ç„¡è¦–ã™ã‚‹
                const key = e.key.toLowerCase();
                if (!this.spaceToggle.checked && key === ' ') {
                     // ã‚¹ãƒšãƒ¼ã‚¹ã¯å˜èªã®åŒºåˆ‡ã‚Šã§ã¯ãªã„ãŸã‚ã€ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ–‡å­—ã¨ã—ã¦æ‰±ã‚ãªã„
                     return;
                }
                
                if (key.length > 1 && key !== ' ') return;

                this.totalTypedChars++;

                // --- æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ START ---
                // 1. ã‚­ãƒ¼å…¥åŠ›å‰ã®çŠ¶æ…‹ã‚’è¨˜éŒ²ã™ã‚‹
                const prevTypedKana = this.wordTyper.getTypedKana();
                // ã‚¹ãƒšãƒ¼ã‚¹å¿…é ˆã§ãªã„å ´åˆã¯ wordBoundaries ã‚’ä½¿ã‚ãªã„ãŸã‚ prevBoundary ã¯ä¸è¦

                // 2. ã‚­ãƒ¼å…¥åŠ›ã‚’å‡¦ç†ã™ã‚‹
                const result = this.wordTyper.update(key);

                if (result.isCorrect) {
                    this.correctTypedKeys++;
                } else {
                    this.incorrectChars++;
                }

                // 3. ã‚­ãƒ¼å…¥åŠ›å¾Œã®çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
                const currentTypedKana = this.wordTyper.getTypedKana();
                
                // 4. ã‚¹ãƒšãƒ¼ã‚¹å…¥åŠ›ã‚’å¿…é ˆã«ã™ã‚‹å ´åˆã®ã¿ã€å˜èªå®Œäº†å¾Œã®ã‚¹ãƒšãƒ¼ã‚¹è‡ªå‹•å…¥åŠ›/å¼·åˆ¶ã‚’å‡¦ç†ã™ã‚‹
                if (this.spaceToggle.checked) {
                    // 4.1. ã‚¿ã‚¤ãƒ—å‰å¾Œã§æ–‡å­—ãŒé€²ã‚“ã§ã„ã‚‹å ´åˆã®ã¿ã€å˜èªå¢ƒç•Œã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
                    if (currentTypedKana.length > prevTypedKana.length) {
                        const prevBoundary = this.wordBoundaries.find(b => b.endIndex === prevTypedKana.length);
                        const currentBoundary = this.wordBoundaries.find(b => b.endIndex === currentTypedKana.length);

                        // 4.2. ä»¥å‰ã¯å¢ƒç•Œã§ã¯ãªãã€ç¾åœ¨ãŒå¢ƒç•Œã§ã‚ã‚‹å ´åˆï¼ˆï¼å˜èªã‚’æ‰“ã¡çµ‚ã‚ã£ãŸç¬é–“ï¼‰
                        if (!prevBoundary && currentBoundary) {
                            // å˜èªãŒå®Œäº†ã—ã¦ã‚‚ã‚¹ãƒšãƒ¼ã‚¹ã¯è‡ªå‹•å…¥åŠ›ã—ãªã„
                        }
                    }
                }
                // --- æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ END ---

                this.updateScrolling();
                this.updateWordHighlight();

                if (this.wordTyper.isFinished()) {
                    this.completeTest();
                    return;
                }
                this.updateStats();
            }

            // --- generateWords ã®ç½®æ›ç‰ˆ ---
            generateWords() {
                const wordCount = this.getWordCount();
                this.words = this.allWords.sort(() => 0.5 - Math.random()).slice(0, wordCount);

                this.wordBoundaries = [];
                let currentKanaLength = 0;
                const isSpaceRequired = this.spaceToggle.checked;

                const kanaParts = this.words.map(w => w.kana.join(''));
                
                // ã‚¹ãƒšãƒ¼ã‚¹å…¥åŠ›ã‚’å¿…é ˆã«ã™ã‚‹ã‹ã©ã†ã‹ã§ fullKanaString ã®ä½œæˆæ–¹æ³•ã‚’å¤‰ãˆã‚‹
                this.fullKanaString = isSpaceRequired ? kanaParts.join('ã€€') : kanaParts.join('');

                // ã‚¯ãƒªã‚¢
                this.wordStream.innerHTML = '';

                // ä¸€æ—¦ã™ã¹ã¦ã®å˜èªã‚’è¿½åŠ ã—ã¦ã‹ã‚‰è¡Œãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆæŠ˜ã‚Šè¿”ã—ï¼‰ã‚’è©•ä¾¡ã™ã‚‹
                this.words.forEach((word, index) => {
                    const wordEl = document.createElement('span');
                    wordEl.id = `word-span-${index}`;
                    wordEl.className = 'word';
                    wordEl.textContent = word.text;
                    this.wordStream.appendChild(wordEl);
                    
                    // --- ä¿®æ­£ç®‡æ‰€: ã“ã“ã‹ã‚‰ ---
                    // æœ€å¾Œã®å˜èªã§ãªã‘ã‚Œã°ã€ã‚¹ãƒšãƒ¼ã‚¹å¿…é ˆã®æœ‰ç„¡ã«é–¢ã‚ã‚‰ãšã€
                    // DOMä¸Šã§ã®è¦–è¦šçš„ãªåŒºåˆ‡ã‚Šã¨ã—ã¦ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ï¼ˆcreateTextNode(' ')ï¼‰ã‚’è¿½åŠ ã™ã‚‹
                    if (index < this.words.length - 1) {
                         const space = document.createTextNode(' ');
                         this.wordStream.appendChild(space);
                    }
                    // --- ä¿®æ­£ç®‡æ‰€: ã“ã“ã¾ã§ ---

                    const kanaLength = kanaParts[index].length;
                    this.wordBoundaries.push({
                        startIndex: currentKanaLength,
                        endIndex: currentKanaLength + kanaLength,
                        element: wordEl
                    });
                    
                    // fullKanaString ã«å«ã¾ã‚Œã‚‹ã‚¹ãƒšãƒ¼ã‚¹åˆ†ã‚’åŠ ç®—ï¼ˆã“ã‚Œã¯ã‚¹ãƒšãƒ¼ã‚¹å¿…é ˆã®å ´åˆã®ã¿ï¼‰
                    currentKanaLength += kanaLength + (isSpaceRequired ? 1 : 0);
                });

                // WordTyper ã‚’ä½œã‚‹å‰ã«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’ç¢ºå®šã™ã‚‹
                this.calculateLines();

                this.wordTyper = new WordTyper(this.fullKanaString);

                // è¡¨ç¤ºæ ã®é«˜ã•ã‚’å˜èªè¡Œæ•°ã«å¿œã˜ã¦èª¿æ•´ã™ã‚‹
                this.adjustWordDisplayHeight();

                this.updateScrolling();
                this.updateWordHighlight();
            }

            // --- calculateLines ã®ç½®æ›ç‰ˆ ---
            calculateLines() {
                // lineBreakWordIndices ã‚’è¡Œã®é–‹å§‹å˜èªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ä½œã‚‹
                this.lineBreakWordIndices = [0];
                const wordSpans = Array.from(this.wordStream.querySelectorAll('.word'));
                if (wordSpans.length === 0) return;

                let lastOffsetTop = wordSpans[0].offsetTop;
                for (let i = 1; i < wordSpans.length; i++) {
                    const t = wordSpans[i].offsetTop;
                    // offsetTop ãŒå¤‰åŒ–ã—ãŸã‚‰æ”¹è¡ŒãŒç™ºç”Ÿã—ãŸã¨ã¿ãªã™
                    if (t > lastOffsetTop + 1) { // å¾®å°å·®ã‚’å¸å
                        this.lineBreakWordIndices.push(i);
                        lastOffsetTop = t;
                    }
                }
                // æœ€å¾Œã®è¡Œã‚‚æ„è­˜ã—ã¦ãŠãï¼ˆè¡Œæ•°ã‚’å®¹æ˜“ã«ç®—å‡ºã™ã‚‹ãŸã‚ï¼‰
                // lineBreakWordIndices é…åˆ—ã¯å„è¡Œã®å…ˆé ­ word index ã‚’ä¿æŒã™ã‚‹
            }

            // --- æ–°è¦è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰: è¡¨ç¤ºæ é«˜ã•èª¿æ•´ ---
            // æ—¢å­˜ã® adjustWordDisplayHeight() ã‚’ã“ã®å®Ÿè£…ã«ç½®ãæ›ãˆã¦ãã ã•ã„
            adjustWordDisplayHeight() {
                const MAX_LINES = 5;

                if (!this.lineBreakWordIndices || this.lineBreakWordIndices.length === 0) {
                    this.wordDisplay.style.height = '';
                    return;
                }

                // è¡Œæ•°ã‚’å–å¾—ï¼ˆlineBreakWordIndices ã¯å„è¡Œã®å…ˆé ­å˜èªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
                const lineCount = this.lineBreakWordIndices.length;

                // å®Ÿéš›ã«ä½¿ç”¨ã™ã‚‹è¡Œæ•°ã¯ lineCount ã¨ MAX_LINES ã®å°ã•ã„æ–¹
                const usedLines = Math.min(lineCount, MAX_LINES);

                // è¡Œé«˜(px)ã‚’å–å¾—ã™ã‚‹ã€‚ã¾ãš wordStream å†…ã®æœ€åˆã® word è¦ç´ ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
                let lineHeightPx = 0;
                const sampleEl = this.wordStream.querySelector('.word');
                if (sampleEl) {
                    const cs = getComputedStyle(sampleEl);
                    lineHeightPx = parseFloat(cs.lineHeight) || 0;
                }
                if (!lineHeightPx) {
                    const cs2 = getComputedStyle(this.wordDisplay);
                    lineHeightPx = parseFloat(cs2.lineHeight) || parseFloat(cs2.fontSize) * 2.2 || 40;
                }

                // wordDisplay ã®ä¸Šä¸‹ padding ã‚’è€ƒæ…®
                const wdCs = getComputedStyle(this.wordDisplay);
                const paddingTop = parseFloat(wdCs.paddingTop) || 0;
                const paddingBottom = parseFloat(wdCs.paddingBottom) || 0;
                const extra = 6; // å¾®èª¿æ•´ç”¨ä½™ç™½(px)

                // è¨ˆç®—ï¼šä½¿ç”¨è¡Œæ•° * è¡Œé«˜ + padding + ä½™ç™½
                const desiredHeight = Math.min(
                    usedLines * lineHeightPx + paddingTop + paddingBottom + extra,
                    // CSS å´ã® max-height ã§ã‚‚ä¸Šé™ãŒã‹ã‹ã‚‹ãŸã‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é«˜ã•ãƒ™ãƒ¼ã‚¹ã®å®‰å…¨ä¸Šé™ã‚‚è¨­å®š
                    window.innerHeight * 0.8
                );

                this.wordDisplay.style.height = `${Math.round(desiredHeight)}px`;
            }


            // --- ç½®æ›ã™ã‚‹é–¢æ•°é–‹å§‹ ---
            updateWordHighlight() {
                const typedLength = this.wordTyper.getTypedKana().length;
                let currentWordIndex = -1;

                this.wordBoundaries.forEach((boundary, index) => {
                    boundary.element.classList.remove('current');
                    if (typedLength >= boundary.startIndex && typedLength < boundary.endIndex) {
                        boundary.element.classList.add('current');
                        currentWordIndex = index;
                    }
                });

                if (currentWordIndex === -1 && typedLength >= this.fullKanaString.length) {
                    this.wordBoundaries[this.wordBoundaries.length - 1].element.classList.add('current');
                    currentWordIndex = this.wordBoundaries.length - 1;
                }

                if (currentWordIndex > -1) {
                    // ç¾åœ¨ã®å˜èªãŒå±ã™ã‚‹è¡Œç•ªå·ã‚’æ±‚ã‚ã‚‹
                    const currentLine = this.lineBreakWordIndices.findLastIndex(lineStartIndex => currentWordIndex >= lineStartIndex);

                    // æ–°ä»•æ§˜ï¼šå¥‡æ•°è¡Œï¼ˆline index ãŒ 1,3,5...ï¼‰ã«åˆ°é”ã—ãŸã‚‰ã€Œä¸€æ®µä¸Šã€ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹
                    // ä¾‹ï¼šcurrentLine === 1 ã®ã¨ãã¯ 0 è¡Œç›®ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ä¸€æ®µä¸Šã«ãšã‚‰ã™
                    // lastScrolledLine ã«ã¯æœ€å¾Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãŸã€ŒåŸºæº–ã¨ãªã‚‹è¡Œç•ªå·ã€ã‚’ä¿æŒã—ã¦é‡è¤‡ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                    if (currentLine >= 1 && (currentLine % 2) === 1) {
                        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å…ˆã®è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆè¡¨ç¤ºã®ãƒˆãƒƒãƒ—ã«æŒã£ã¦ãã‚‹è¡Œã® start indexï¼‰
                        const scrollToLineIndex = currentLine - 1;

                        // åŒã˜ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å…ˆã«æ—¢ã«ç§»å‹•æ¸ˆã¿ã§ã‚ã‚Œã°ä½•ã‚‚ã—ãªã„
                        if (this.lastScrolledLine !== scrollToLineIndex) {
                            const firstWordIndexOfTargetLine = this.lineBreakWordIndices[scrollToLineIndex];
                            const firstWordEl = this.wordBoundaries[firstWordIndexOfTargetLine].element;
                            const scrollAmount = firstWordEl.offsetTop - this.wordBoundaries[0].element.offsetTop;
                            const extraScroll = 3;
                            this.wordStream.style.transform = `translateY(-${scrollAmount + extraScroll}px)`;
                            this.lastScrolledLine = scrollToLineIndex;
                        }
                    } else {
                        // currentLine ãŒå¶æ•°ã‹ 0 ã®ã¨ãã¯ãƒˆãƒƒãƒ—ã«æˆ»ã™ï¼ˆå¿…è¦ãªã‚‰ï¼‰
                        // ãŸã ã—æ—¢ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦ã„ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
                        if (currentLine === 0 && this.lastScrolledLine !== 0) {
                            this.wordStream.style.transform = `translateY(0px)`;
                            this.lastScrolledLine = 0;
                        }
                        // ãã®ä»–ï¼ˆå¶æ•°è¡Œã§ã‹ã¤ lastScrolledLine ãŒåˆ¥ã®å€¤ã®å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¶­æŒã—ãŸã„ã®ã§ä½•ã‚‚ã—ãªã„ï¼‰
                    }
                }
            }
            // --- ç½®æ›ã™ã‚‹é–¢æ•°çµ‚äº† ---


            updateScrolling() {
                if (!this.wordTyper) return;

                const typed = this.wordTyper.getTypedKana();
                const typedLength = typed.length;
                
                let untypedForDisplay;
                let typedForDisplay;

                if (this.spaceToggle.checked) {
                    untypedForDisplay = this.fullKanaString.substring(typedLength);
                    typedForDisplay = typed;
                } else {
                    // Rebuild the untyped part with spaces for display
                    const untyped_parts = [];
                    for (const boundary of this.wordBoundaries) {
                        if (boundary.endIndex <= typedLength) {
                            continue; // Already typed
                        }
                        
                        const word = this.fullKanaString.substring(boundary.startIndex, boundary.endIndex);

                        if (boundary.startIndex < typedLength) {
                            // Partially typed word, take the untyped part
                            untyped_parts.push(word.substring(typedLength - boundary.startIndex));
                        } else {
                            // Fully untyped word
                            untyped_parts.push(word);
                        }
                    }
                    untypedForDisplay = untyped_parts.join('ã€€');

                    // Rebuild the typed part with spaces for display
                    const typed_parts = [];
                    for (const boundary of this.wordBoundaries) {
                        if (boundary.startIndex >= typedLength) {
                            break; // Stop when we reach untyped words
                        }
                        
                        const word = this.fullKanaString.substring(boundary.startIndex, boundary.endIndex);

                        if (boundary.endIndex > typedLength) {
                            // Partially typed word
                            typed_parts.push(word.substring(0, typedLength - boundary.startIndex));
                        } else {
                            // Fully typed word
                            typed_parts.push(word);
                        }
                    }
                    typedForDisplay = typed_parts.join('ã€€');

                    // Add a trailing space to the typed part if a word was just completed
                    const atWordBoundary = this.wordBoundaries.some(b => b.endIndex === typedLength);
                    const isNotTheEnd = typedLength < this.fullKanaString.length;
                    if (atWordBoundary && isNotTheEnd) {
                        typedForDisplay += 'ã€€';
                    }
                }

                this.kanaStream.innerHTML = 
                    `<span class="typed">${typedForDisplay}</span>` +
                    `<span id="cursor"></span>` +
                    `<span class="untyped">${untypedForDisplay}</span>`;

                const cursorEl = document.getElementById('cursor');
                if (cursorEl) {
                    const scrollOffset = cursorEl.offsetLeft;
                    this.kanaStream.style.transform = `translateX(-${scrollOffset}px)`;
                }
                this.updateProgress();
            }

            startTest() {
                if (this.isActive || this.isCompleted) return;
                
                this.isActive = true;
                this.startTime = Date.now();
                this.wordDisplay.classList.add('active');
                
                const timeLimit = this.getTimeLimit();
                if (timeLimit > 0) {
                    this.timeLeft = timeLimit;
                    this.timerElement.textContent = this.timeLeft;
                    this.startTimer();
                }
            }

            startTimer() {
                if (this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    this.timeLeft--;
                    this.timerElement.textContent = this.timeLeft;
                    this.updateStats();
                    if (this.timeLeft <= 0) {
                        this.completeTest();
                    }
                }, 1000);
            }

            completeTest() {
                this.isActive = false;
                this.isCompleted = true;
                this.endTime = Date.now();
                if (this.timer) clearInterval(this.timer);
                this.wordDisplay.classList.remove('active');
                this.showResults();
            }

            updateStats() {
                const elapsedSeconds = this.startTime ? (Date.now() - this.startTime) / 1000 : 0;
                if (elapsedSeconds === 0) return;

                const kps = this.correctTypedKeys / elapsedSeconds;
                const kpm = kps * 60;
                const accuracy = this.totalTypedChars > 0 
                    ? Math.round((this.correctTypedKeys / this.totalTypedChars) * 100)
                    : 100;

                this.kpmElement.textContent = Math.round(kpm);
                this.kpsElement.textContent = kps.toFixed(2);
                this.accuracyElement.textContent = `${Math.max(0, accuracy)}%`;
            }

            updateProgress() {
                if (!this.wordTyper) return;
                const progress = (this.wordTyper.getTypedKana().length / this.fullKanaString.length) * 100;
                this.progressFill.style.width = `${progress}%`;
            }

            showResults() {
                const elapsedSeconds = (this.endTime - this.startTime) / 1000;
                const kps = elapsedSeconds > 0 ? this.correctTypedKeys / elapsedSeconds : 0;
                const kpm = kps * 60;
                const accuracy = this.totalTypedChars > 0 
                    ? Math.round((this.correctTypedKeys / this.totalTypedChars) * 100)
                    : 100;
                const level = getLevel(kpm);

                document.getElementById('finalLevel').textContent = level;
                document.getElementById('finalKPM').textContent = Math.round(kpm);
                document.getElementById('finalKPS').textContent = kps.toFixed(2);
                document.getElementById('finalAccuracy').textContent = `${Math.max(0, accuracy)}%`;
                document.getElementById('finalTime').textContent = `${Math.round(elapsedSeconds)}s`;

                this.results.classList.add('show');
                // --- ãƒ™ã‚¹ãƒˆè¨˜éŒ²æ›´æ–°ã®åˆ¤å®šã¨ä¿å­˜ ---
const elapsedSeconds = (this.endTime - this.startTime) / 1000;
const currentRecord = {
    level: level,
    wordCount: this.getWordCount(),
    kpm: kpm,
    kps: kps,
    accuracy: accuracy,
    elapsedSeconds: elapsedSeconds,
    timestamp: Date.now()
};
tryUpdateBestRecord(currentRecord);

this.results.classList.add('show');

            }

            restart() {
                if (this.timer) clearInterval(this.timer);
                this.initGame();
                
                const timeLimit = this.getTimeLimit();
                this.timeLeft = timeLimit > 0 ? timeLimit : 0;

                this.wordDisplay.classList.remove('active');
                this.results.classList.remove('show');
                this.progressFill.style.width = '0%';
                this.timerElement.textContent = timeLimit > 0 ? timeLimit : 'âˆ';
                
                this.generateWords();
                this.updateStats();
            }
        }

        function populateLevelChart() {
            const tableBody = document.querySelector('#levelTable tbody');
            if (!tableBody) return;

            let tableContent = '';
            levelMap.forEach(item => {
                tableContent += `
                    <tr>
                        <td>${item.level}</td>
                        <td>${item.kpm >= 1000 ? Math.round(item.kpm) : item.kpm.toFixed(2)}</td>
                    </tr>
                `;
            });
            tableBody.innerHTML = tableContent;
        }

        async function init() {
            try {
                const response = await fetch('khjy.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                new TypingTest(data.list);
            } catch (error) {
                console.error("Could not load word list:", error);
                document.getElementById('wordDisplay').textContent = 'å˜èªãƒªã‚¹ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            init();
            populateLevelChart();
        });
        document.addEventListener('DOMContentLoaded', () => {
    init();
    populateLevelChart();
    renderBestRecord(); // ãƒ™ã‚¹ãƒˆã‚’è¡¨ç¤º
});

    })();
    </script>
</body>
</html>
